{"version":3,"file":"contentScript.js","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://playground-chromeextension/./src/Error/Error.ts","webpack://playground-chromeextension/./src/utils/constants.ts","webpack://playground-chromeextension/./src/utils/helpers.ts","webpack://playground-chromeextension/./src/utils/selectors.ts","webpack://playground-chromeextension/webpack/bootstrap","webpack://playground-chromeextension/webpack/runtime/define property getters","webpack://playground-chromeextension/webpack/runtime/hasOwnProperty shorthand","webpack://playground-chromeextension/webpack/runtime/make namespace object","webpack://playground-chromeextension/./src/contentScript/contentScript.ts"],"sourcesContent":["class Err {\r\n    constructor(message) {\r\n        this.message = message;\r\n        this.name = 'Error'; // (組み込みのエラークラスごとに異なる名前)\r\n    }\r\n}\r\nexport class ErrorBase extends Err {\r\n    constructor(message) {\r\n        super(message);\r\n        this.name = this.constructor.name;\r\n    }\r\n}\r\nexport class DomManipulationError extends ErrorBase {\r\n    constructor(message) {\r\n        super(message);\r\n        this.name = 'DomManipulationError';\r\n    }\r\n}\r\n/***********\r\n * Among contentScript.js\r\n * Thrown if subtitle is not English, or Transcript is not opened\r\n * */\r\nexport class PageStatusNotReadyError extends ErrorBase {\r\n    constructor(message) {\r\n        super(message);\r\n        this.name = 'PageStatusNotReadyError';\r\n    }\r\n}\r\n","/**************************************************\r\n * constants\r\n * ________________________________________________\r\n *\r\n * ************************************************/\r\nexport const _key_of_model_state__ = '_key_of_model_state__@&%8=8';\r\nexport const urlPattern = /https:\\/\\/www.udemy.com\\/course\\/*/gm;\r\nexport const extensionStatus = {\r\n    working: 'working',\r\n    notWorking: 'notWorking',\r\n    idle: 'idle',\r\n};\r\nexport const extensionNames = {\r\n    popup: 'popup',\r\n    contentScript: 'contentScript',\r\n    controller: 'controller',\r\n    captureSubtitle: 'captureSubtitle',\r\n    background: 'background',\r\n};\r\n//\r\n// Updated\r\n//\r\nexport const orderNames = {\r\n    // // Inject content script order\r\n    // injectCaptureSubtitleScript: 'injectCaptureSubtitleScript',\r\n    // injectExTranscriptScript: 'injectExTranscriptScript',\r\n    // From background to contentScript\r\n    sendStatus: 'sendStatus',\r\n    // from controller to background\r\n    sendSubtitles: 'sendSubtitles',\r\n    // order to disconnect port\r\n    disconnect: 'disconnect',\r\n    // from popup inquire the url is correct\r\n    inquireUrl: 'inquireUrl',\r\n    // from popup, run process\r\n    run: 'run',\r\n    // reset content script\r\n    reset: 'reset',\r\n    // Turn Off ExTranscript\r\n    turnOff: 'turnOff',\r\n    // something succeeded\r\n    success: 'success',\r\n    // NOTE: new added\r\n    // Is the page moved to text page?\r\n    isPageIncludingMovie: 'isPageIncludingMovie'\r\n};\r\n// --- constants for controller.js -------------------------------\r\n// // To pass to setTimeout\r\n// export const TEN_SEC: number = 10000;\r\n// transcript要素はwinodwサイズが975px以下の時にdashboardへ以上でsidebarへ移動する\r\nexport const RESIZE_BOUNDARY = 975;\r\n// sidebarのwidthは2通りあって、\r\n// 975px < w =< 1182pxだと300px, w > 1182pxで25%\r\nexport const SIDEBAR_WIDTH_BOUNDARY = 1182;\r\n// window onResize時の反応遅延速度\r\nexport const RESIZE_TIMER = 100;\r\nexport const SIGNAL = {\r\n    widthStatus: {\r\n        wideview: true,\r\n        middleview: false,\r\n    },\r\n};\r\nexport const positionStatus = {\r\n    sidebar: 'sidebar',\r\n    noSidebar: 'noSidebar',\r\n};\r\nexport const viewStatusNames = {\r\n    wideView: 'wideView',\r\n    middleView: 'middleView',\r\n};\r\n// ---- ABOUT PORT ----------------------------------\r\nexport const port_names = {\r\n    _requiring_subtitles: '_port_name_require_subtitles',\r\n    _injected_contentScript: '_port_name_injected_contentScript',\r\n};\r\n// // Usage\r\n// type _order = orderTypes[];\r\n// const oo: _order = [\r\n//   orderNames.sendStatus, orderNames.disconnect\r\n// ];\r\n// console.log(oo);\r\n// const messageHandler = (m: iMessage): void => {\r\n//   const { from, to, order } = m;\r\n//   // もしもorderプロパティが含まれていて、中身があれば\r\n//   if (order && order.length) {\r\n//     console.log(\"there is order\");\r\n//     //\r\n//     // この時点だとorderが何者かわからないみたいだからincludes()メソッドなんて使えないよ\r\n//     // というエラーが出る\r\n//     // でも使えた\r\n//     // codesandboxでは\r\n//     if (order.includes(orderNames.sendStatus)) {\r\n//       console.log(\"SEND STATUS\");\r\n//     }\r\n//     if (order.includes(orderNames.disconnect)) {\r\n//       console.log(\"DISCONNECT\");\r\n//     }\r\n//   }\r\n// };\r\n// messageHandler({\r\n//   from: \"background\",\r\n//   to: \"content script\",\r\n//   order: [\r\n//     orderNames.sendStatus, orderNames.disconnect\r\n//   ]\r\n// });\r\n// messageHandler({\r\n//   from: \"background\",\r\n//   to: \"content script\",\r\n//   order: []\r\n// });\r\n// messageHandler({\r\n//   from: \"background\",\r\n//   to: \"content script\"\r\n// });\r\n/*\r\n## 変数がいくつかの特定の値を持つように強制する方法\r\n\r\nhttps://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types\r\n\r\n```TypeScript\r\n\r\n// -- example 1 --\r\n\r\nlet x: \"hello\" = \"hello\";\r\n// OK\r\nx = \"hello\";\r\n// ...\r\nx = \"howdy\";\r\n// Type '\"howdy\"' is not assignable to type '\"hello\"'.\r\n\r\n// -- example 2 --\r\n\r\nfunction printText(s: string, alignment: \"left\" | \"right\" | \"center\") {\r\n  // ...\r\n}\r\nprintText(\"Hello, world\", \"left\");\r\nprintText(\"G'day, mate\", \"centre\");\r\nArgument of type '\"centre\"' is not assignable to parameter of type '\"left\" | \"right\" | \"center\"'.\r\n```\r\n\r\nhttps://typescript-jp.gitbook.io/deep-dive/type-system/literal-types\r\n\r\n\r\n\r\n*/\r\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __rest = (this && this.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n};\r\nexport const deepCopier = (data) => {\r\n    return JSON.parse(JSON.stringify(data));\r\n};\r\nexport const sendMessageToTabsPromise = (tabId, message) => __awaiter(void 0, void 0, void 0, function* () {\r\n    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {\r\n        chrome.tabs.sendMessage(tabId, message, (response) => __awaiter(void 0, void 0, void 0, function* () {\r\n            const { complete } = response, rest = __rest(response, [\"complete\"]);\r\n            complete\r\n                ? resolve(rest)\r\n                : reject(\"Send message to tabs went something wrong\");\r\n        }));\r\n    }));\r\n});\r\nexport const sendMessagePromise = (message) => __awaiter(void 0, void 0, void 0, function* () {\r\n    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {\r\n        chrome.runtime.sendMessage(message, (response) => __awaiter(void 0, void 0, void 0, function* () {\r\n            const { complete } = response, rest = __rest(response, [\"complete\"]);\r\n            if (complete)\r\n                resolve(rest);\r\n            else\r\n                reject();\r\n        }));\r\n    }));\r\n});\r\nexport const tabsQuery = () => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        const w = yield chrome.windows.getCurrent();\r\n        const tabs = yield chrome.tabs.query({\r\n            active: true,\r\n            windowId: w.id,\r\n        });\r\n        return tabs[0];\r\n    }\r\n    catch (err) {\r\n        console.error(err.message);\r\n    }\r\n});\r\n// # mark以下を切除した文字列を返す\r\n// なければそのまま引数のurlを返す\r\nexport const exciseBelowHash = (url) => {\r\n    return url.indexOf(\"#\") < 0 ? url : url.slice(0, url.indexOf(\"#\"));\r\n};\r\n/*********************\r\n * Repeat given async callback function.\r\n *\r\n * @param {action} Function:\r\n * the function that will be executed repeatedly.\r\n * NOTE: Function must returns boolean.\r\n * @param {timesoutResolve} boolean: true to allow this function to return false.\r\n * @param {times} number: Number that how many times repeat.\r\n * Default to 10.\r\n * @param {interval} number: Microseconds that repeat interval.\r\n * Default to 200.\r\n * @return {Promise} Promise objects represents boolean. True as matched, false as no-matched.\r\n * @throws\r\n *\r\n * 参考：https://stackoverflow.com/questions/61908676/convert-setinterval-to-promise\r\n *\r\n * 参考：https://levelup.gitconnected.com/how-to-turn-settimeout-and-setinterval-into-promises-6a4977f0ace3\r\n * */\r\nexport const repeatActionPromise = (action, timeoutAsResolve = false, interval = 200, times = 10) => __awaiter(void 0, void 0, void 0, function* () {\r\n    return new Promise((resolve, reject) => {\r\n        let intervalId;\r\n        let triesLeft = times;\r\n        intervalId = setInterval(function () {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                console.log(`loop tries left...${triesLeft}`);\r\n                if (yield action()) {\r\n                    clearInterval(intervalId);\r\n                    // 正常な終了としてtrueを返す\r\n                    resolve(true);\r\n                }\r\n                else if (triesLeft <= 1 && timeoutAsResolve) {\r\n                    clearInterval(intervalId);\r\n                    // 正常な終了でfalseを返す\r\n                    resolve(false);\r\n                }\r\n                else if (triesLeft <= 1 && !timeoutAsResolve) {\r\n                    clearInterval(intervalId);\r\n                    // 例外エラーとしてcatchされる\r\n                    reject();\r\n                }\r\n                triesLeft--;\r\n            });\r\n        }, interval);\r\n    });\r\n});\r\n// --- USAGE EXAMPLE --------------------------------------\r\n// const randomMath = (): boolean => {\r\n//   return Math.random() * 0.8 > 400 ? true : false;\r\n// }\r\n// const repeatQuerySelector = async (): Promise<boolean> => {\r\n//   try {\r\n//     // 第二引数をfalseにすると、ループで一度もマッチしなかった場合、例外エラーになる\r\n//     // なので例外エラーにしたくなくて、falseも受け取りたいときは\r\n//     // 第二引数をtrueにすること\r\n//       const r: boolean = await repeatActionPromise(\r\n//           function(): boolean {return randomMath()}, true\r\n//       );\r\n//       return r;\r\n//   }\r\n//   catch(err) {\r\n//     console.log(\"caught error\");\r\n//       // console.error(`Error: Could not query dom. ${err.message}`)\r\n//       throw err;\r\n//   }\r\n// }\r\n// (async function() {\r\n//   const res = await repeatQuerySelector();\r\n//   console.log(\"RESULT:\");\r\n//   console.log(res);\r\n// })();\r\n/****************\r\n * Wrapper of setTimeout with given function.\r\n *\r\n *\r\n * */\r\nexport const delay = (action, timer) => {\r\n    return new Promise((resolve, reject) => {\r\n        setTimeout(function () {\r\n            const r = action();\r\n            resolve(r);\r\n        }, timer);\r\n    });\r\n};\r\n","/***************************************************\r\n * SELECTORS\r\n * ________________________________________________\r\n *\r\n *\r\n *\r\n *\r\n * **************************************************/\r\n// --- Selectors related to Transcript ---------------------------\r\n// Udemy講義ページが動画ページならこのセレクタが一致する\r\n// テキストページとかなら一致しない\r\nexport const videoContainer = \"div.video-viewer--container--23VX7\";\r\nexport const transcript = {\r\n    // HTMLSpanElement which is Highlight as current subtitle on movie.\r\n    highlight: \"span.transcript--highlight-cue--1bEgq\",\r\n    // NodeListOf<HTMLSpanElement> which are list of subtitle element.\r\n    transcripts: \"div.transcript--cue-container--wu3UY p.transcript--underline-cue--3osdw span\",\r\n    // top element of side bar\r\n    noSidebar: \"div.app--no-sidebar--1naXE\",\r\n    sidebar: \"div.has-sidebar\",\r\n    // High level element of Movie element\r\n    movieContainer: \"div.app--curriculum-item--2GBGE\",\r\n    // Movie Replay button\r\n    replayButton: \"button[data-purpose='video-play-button-initial']\",\r\n    // Controlbar\r\n    controlbar: \"div.control-bar--control-bar--MweER[data-purpose='video-controls']\",\r\n    //\r\n};\r\n// --- Selectors related to control bar. -------------------------\r\nexport const controlBar = {\r\n    // \"closed captioning\"\r\n    cc: {\r\n        // 字幕メニューpopupボタン\r\n        popupButton: \"button[data-purpose='captions-dropdown-button']\",\r\n        // textContentで取得できる言語を取得可能\r\n        //   languageList:\r\n        //     \"button.udlite-btn.udlite-btn-large.udlite-btn-ghost.udlite-text-sm.udlite-block-list-item.udlite-block-list-item-small.udlite-block-list-item-neutral > div.udlite-block-list-item-content\",\r\n        //\r\n        // 言語リストを取得するには一旦languageButtonsを取得してからそれからquerySelectorする\r\n        // いらないかも\r\n        menuCheckButtons: \"button\",\r\n        menuList: \".udlite-block-list-item-content\",\r\n        menuListParent: \"ul[role='menu'][data-purpose='captions-dropdown-menu']\",\r\n        // 上記のセレクタのラッパーボタン。\r\n        // 属性`aria-checked`で選択されているかどうかわかる\r\n        checkButtons: \"button.udlite-btn.udlite-btn-large.udlite-btn-ghost.udlite-text-sm.udlite-block-list-item.udlite-block-list-item-small.udlite-block-list-item-neutral\",\r\n    },\r\n    transcript: {\r\n        toggleButton: \"button[data-purpose='transcript-toggle']\",\r\n    },\r\n    theatre: {\r\n        theatreToggle: \"button[data-purpose='theatre-mode-toggle-button']\",\r\n    },\r\n};\r\n// --- Selectors related ex-transcript -----------------------\r\nexport const EX = {\r\n    // Udemy page-specific selector\r\n    sidebarParent: \".app--content-column--HC_i1\",\r\n    noSidebarParent: \".app--dashboard-content--r2Ce9\",\r\n    movieContainer: \".app--body-container\",\r\n    // 独自selector `ex--`を接頭辞とする\r\n    // sidebar ex-transcript selectors\r\n    sidebarWrapper: \".ex--sidebar-column\",\r\n    sidebarSection: \".ex--sidebar--sidebar\",\r\n    sidebarHeader: \".ex--sidebar--sidebar-header\",\r\n    sidebarContent: \".ex--sidebar--content\",\r\n    sidebarContentPanel: \".ex--sidebar-content-panel\",\r\n    sidebarCueContainer: \".ex--sidebar-transcript--cue-container\",\r\n    sidebarFooter: \".ex--sidebar-transcript--autoscroll-wrapper\",\r\n    // sidebar width in case more than SIDEBAR_WIDTH_BOUNDARY\r\n    wideView: \".ex--sidebar--wideview\",\r\n    // sidebar width in case less than SIDEBAR_WIDTH_BOUNDARY\r\n    middleView: \".ex--sidebar--middleview\",\r\n    // bottom ex-transcript selectors\r\n    dashboardTranscriptWrapper: \".ex--dashboard-transcript-wrapper\",\r\n    dashboardTranscriptHeader: \".ex--dashboard-transcript--header\",\r\n    dashboardTranscriptPanel: \".ex--dashboard-transcript--transcript-panel\",\r\n    dashboardTranscriptCueContainer: \".ex--dashboard-transcript--cue-container\",\r\n    dashboardTranscriptCue: \".ex--dashboard-transcript--cue--underline\",\r\n    dashboardTranscriptCueText: \"span[data-purpose='ex--dashboard-cue-text']\",\r\n    dashboardTranscriptBottom: \".ex--dashboard-transcript--autoscroll-wrapper\",\r\n    // To Highlight Transcriot Cue Container\r\n    highlight: \".--highlight--\",\r\n};\r\n// --- LEGACY -------------------------\r\n// sectionTitle: 'div.udlite-text-md.video-viewer--title-overlay--OoQ6e',\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/***********************************************************\r\nstatic content script\r\n___________________________________________________________\r\n\r\n\r\n機能：\r\n    1. Udemy講義ページのトランスクリプト機能がONになっているか検知する\r\n    2. Udemy講義ページの字幕の言語が英語になっているか検知する\r\n    3. 1, 2を調査して必要に応じてbackground scriptへ送信する\r\n\r\nInjectタイミング:\r\n    動的content scriptとして、\r\n    Udemyの講義ページURLへマッチするwebページにおいて、\r\n    POPUP上の実行ボタンが押されたらinjectされる\r\n\r\n通信に関して：\r\n    single message passing機能でbackground.jsと通信する\r\n\r\n\r\nhandlerOfControlbar()でコントロールバー上のクリックイベントを監視する\r\nmoControlbarでコントロールバー上でトランスクリプト・トグルボタンが現れたか消えたかを監視する\r\n\r\n************************************************************/\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport * as selectors from '../utils/selectors';\r\nimport { extensionNames, orderNames, } from '../utils/constants';\r\nimport { sendMessagePromise, repeatActionPromise, } from '../utils/helpers';\r\nimport { DomManipulationError, } from '../Error/Error';\r\n//\r\n// --- GLOBALS ---------------------------------------------------\r\n//\r\nconst INTERVAL_TIME = 500;\r\nlet moControlbar = null;\r\nlet controlbar = null;\r\n//\r\n// --- chrome API Listeners -------------------------------------\r\n//\r\n/******************************************************\r\n * @param {iMessage} message\r\n * @param {function} sendResponse:\r\n * Invoke this function to response. The function is required.\r\n * @return {boolean} :\r\n * `return true` to wait for sendResponse() solved asynchronously.\r\n * DO NOT return Promise<boolean>.\r\n * It never works.\r\n *\r\n * Any asynchronous function must be solved with Promise Chain.\r\n * (Or use IIFE to be able to use async/await)\r\n * And every order should be responsed by invoking sendResponse with `{complete: true}`.\r\n * */\r\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\r\n    console.log('CONTENT SCRIPT GOT MESSAGE');\r\n    const { from, order, to } = message;\r\n    const response = {\r\n        from: extensionNames.contentScript,\r\n        to: from,\r\n    };\r\n    if (to !== extensionNames.contentScript)\r\n        return;\r\n    // ORDERS:\r\n    if (order && order.length) {\r\n        // SEND STATUS\r\n        if (order.includes(orderNames.sendStatus)) {\r\n            console.log('Order: SEND STATUS');\r\n            try {\r\n                const isEnglish = isSubtitleEnglish();\r\n                let isOpen = false;\r\n                const toggle = document.querySelector(selectors.controlBar.transcript.toggleButton);\r\n                if (!toggle)\r\n                    isOpen = false;\r\n                else\r\n                    isOpen = isTranscriptOpen();\r\n                response.language = isEnglish;\r\n                response.isTranscriptDisplaying = isOpen;\r\n                response.success = true;\r\n            }\r\n            catch (err) {\r\n                response.success = false;\r\n                response.error = err;\r\n            }\r\n            finally {\r\n                response.complete = true;\r\n                sendResponse(response);\r\n            }\r\n        }\r\n        // RESET\r\n        if (order.includes(orderNames.reset)) {\r\n            console.log('Order: RESET');\r\n            handlerOfReset()\r\n                .then(() => {\r\n                response.success = true;\r\n            })\r\n                .catch((err) => {\r\n                console.error(err.message);\r\n                response.success = false;\r\n                response.error = err;\r\n            })\r\n                .finally(() => {\r\n                response.complete = true;\r\n                sendResponse(response);\r\n            });\r\n        }\r\n        // Require to make sure the page is including movie container or not.\r\n        if (order.includes(orderNames.isPageIncludingMovie)) {\r\n            console.log('Order: Is this page including movie container?');\r\n            repeatCheckQueryAcquired(selectors.videoContainer, true)\r\n                .then((r) => {\r\n                response.isPageIncludingMovie = r;\r\n                response.success = true;\r\n            })\r\n                .catch((err) => {\r\n                console.error(err);\r\n                response.success = false;\r\n                response.error = err;\r\n            })\r\n                .finally(() => {\r\n                response.complete = true;\r\n                sendResponse(response);\r\n            });\r\n        }\r\n        // TURN OFF\r\n        if (order.includes(orderNames.turnOff)) {\r\n            console.log('Order: Turn off');\r\n            moControlbar.disconnect();\r\n            controlbar.removeEventListener('click', handlerOfControlbar);\r\n            // moControlbarとcontrolbarはnullにしておく必要があるかな？\r\n            // その後のorderによるなぁ\r\n            response.complete = true;\r\n            sendResponse(response);\r\n        }\r\n    }\r\n    return true;\r\n});\r\n/*****************************************\r\n *  Sends status of injected page to background\r\n * @param order {object}\r\n * */\r\nconst sendToBackground = (order) => __awaiter(void 0, void 0, void 0, function* () {\r\n    console.log('SENDING MESSAGE TO BACKGROUND');\r\n    const { isOpened, isEnglish } = order;\r\n    const m = {\r\n        from: extensionNames.contentScript,\r\n        to: extensionNames.background,\r\n    };\r\n    if (isOpened !== undefined) {\r\n        m['isTranscriptDisplaying'] = isOpened;\r\n    }\r\n    if (isEnglish !== undefined) {\r\n        m['language'] = isEnglish;\r\n    }\r\n    yield sendMessagePromise(m);\r\n});\r\n//\r\n// ---- Event Handlers -----------------------------------------\r\n//\r\n/*************************************************\r\n * Handler of RESET order.\r\n *\r\n * controlbar DOMを取得しなおす\r\n * 伴って、\r\n * controlbarについているリスナの解除、再設定\r\n * controlbarを監視するMutationObserverの再設定\r\n *\r\n * */\r\nconst handlerOfReset = () => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        yield initialize();\r\n    }\r\n    catch (e) {\r\n        throw e;\r\n    }\r\n});\r\n/**************************************************\r\n *  Handler of Click Event on Controlbar\r\n *\r\n * @param {PointEvent} ev\r\n *\r\n *\r\n * setTimeout() callback will be fired after click event has been done immediately.\r\n *\r\n * */\r\nconst handlerOfControlbar = function (ev) {\r\n    // Clickイベント中にDOMを取得しておく...\r\n    // イベントバブリングpath\r\n    const path = ev.composedPath();\r\n    // トランスクリプト・トグルボタン\r\n    const transcriptToggle = document.querySelector(selectors.controlBar.transcript.toggleButton);\r\n    // シアターモード・トグルボタン\r\n    const theaterToggle = document.querySelector(selectors.controlBar.theatre.theatreToggle);\r\n    // クローズド・キャプション・メニュー\r\n    const ccPopupMenu = document.querySelector(selectors.controlBar.cc.menuListParent);\r\n    // [動作確認済] clickイベント完了後に実行したい事柄はsetTimeoutで\r\n    setTimeout(function () {\r\n        // トグルボタンが押されたら\r\n        if (path.includes(transcriptToggle) || path.includes(theaterToggle)) {\r\n            // トランスクリプト・トグルボタンがあるかどうかを確認し、\r\n            // あれば開かれているか調査、\r\n            // なければトランスクリプト非表示として判定する\r\n            let result;\r\n            const t = document.querySelector(selectors.controlBar.transcript.toggleButton);\r\n            if (!t)\r\n                result = false;\r\n            else\r\n                result = isTranscriptOpen();\r\n            sendToBackground({ isOpened: result });\r\n        }\r\n        // cc popup menu内部でクリックイベントが起こったら\r\n        // 字幕が変更されたのか調べる\r\n        if (path.includes(ccPopupMenu)) {\r\n            const r = isSubtitleEnglish();\r\n            sendToBackground({ isEnglish: r });\r\n        }\r\n    }, 200);\r\n};\r\n/*****************************************************\r\n * Check Transcript is opened or not.\r\n *\r\n * @returns {boolean}: true for open, false for not open.\r\n *\r\n * Get DOM everytime this function invoked.\r\n * */\r\nconst isTranscriptOpen = () => {\r\n    const toggleButton = document.querySelector(selectors.controlBar.transcript.toggleButton);\r\n    return toggleButton.getAttribute('aria-expanded') === 'true' ? true : false;\r\n};\r\n/****************************************************\r\n * Check Subtitle language is English or not.\r\n *\r\n * @returns {boolean}: true if it's English, false if not.\r\n * @throws {DomManipulationError} : When dom acquisition failes.\r\n * Exception might be happen when selector is not matches.\r\n *\r\n * Get DOM everytime this function invoked.\r\n */\r\nconst isSubtitleEnglish = () => {\r\n    const listParent = document.querySelector(selectors.controlBar.cc.menuListParent);\r\n    const checkButtons = listParent.querySelectorAll(selectors.controlBar.cc.menuCheckButtons);\r\n    const menuList = listParent.querySelectorAll(selectors.controlBar.cc.menuList);\r\n    if (!listParent || !checkButtons || !menuList)\r\n        throw new DomManipulationError('Failed to manipulate DOM');\r\n    let counter = 0;\r\n    let i = null;\r\n    const els = Array.from(checkButtons);\r\n    for (const btn of els) {\r\n        if (btn.getAttribute('aria-checked') === 'true') {\r\n            i = counter;\r\n            break;\r\n        }\r\n        counter++;\r\n    }\r\n    // NOTE: 字幕リストで何も選択されていないというのは起こりえないはず\r\n    // なのでこのチェック自体が無意味かも\r\n    if (i === null) {\r\n        throw new Error('Error: [isSubtitleEnglish()] Something went wrong but No language is selected');\r\n    }\r\n    const currentLanguage = Array.from(menuList)[i].innerText;\r\n    if (currentLanguage.includes('English') || currentLanguage.includes('英語'))\r\n        return true;\r\n    else\r\n        return false;\r\n};\r\n//\r\n// --- MutationObserver -----------------------------------------\r\n//\r\n// コントロールバーの子要素だけ追加されたのか削除されたのか知りたいので\r\n// childListだけtrueにする\r\nconst config = {\r\n    attributes: false,\r\n    childList: true,\r\n    subtree: false,\r\n};\r\n/*\r\n    NOTE: JavaScript Tips: NodeからElementを取得して、datasetを取得する方法\r\n\r\n    record.removedNodes.forEach((node) => {\r\n        console.log(node);\r\n        console.log(node.childNodes[0]);\r\n        console.log(node.childNodes[0].parentElement);\r\n        console.log(\r\n            node.childNodes[0].parentElement.firstElementChild\r\n        );\r\n        console.log(\r\n            node.childNodes[0].parentElement.firstElementChild\r\n                .attributes\r\n        );\r\n        console.log(\r\n            node.childNodes[0].parentElement.firstElementChild.getAttribute(\r\n                'data-purpose'\r\n            )\r\n        );\r\n*/\r\nconst moCallback = (mr) => {\r\n    let guard = false;\r\n    mr.forEach((record) => {\r\n        if (record.type === 'childList' && !guard) {\r\n            // NOTE: MutationRecord[0]だけしらべればいいので1週目だけでループを止める\r\n            // じゃぁforEach()を使うなという話ではあるけど...\r\n            guard = true;\r\n            // Added Nodes\r\n            record.addedNodes.forEach((node) => {\r\n                const dataPurpose = node.childNodes[0].parentElement.firstElementChild.getAttribute('data-purpose');\r\n                if (dataPurpose && dataPurpose === 'transcript-toggle') {\r\n                    console.log('[contentScript] Appeared Transcript Toggle Button');\r\n                    sendToBackground({ isOpened: isTranscriptOpen() });\r\n                }\r\n            });\r\n            // Removed Nodes\r\n            record.removedNodes.forEach((node) => {\r\n                // これで取得できた！！！\r\n                const dataPurpose = node.childNodes[0].parentElement.firstElementChild.getAttribute('data-purpose');\r\n                if (dataPurpose && dataPurpose === 'transcript-toggle') {\r\n                    console.log('[contentScript] Disappeared Transcript Toggle Button');\r\n                    sendToBackground({ isOpened: false });\r\n                }\r\n            });\r\n        }\r\n    });\r\n};\r\n//\r\n// ---- Other Methods -------------------------------------------\r\n//\r\n/************************************************\r\n *\r\n * 与えられたselectorからDOMが存在するかしらべて\r\n * 真偽値を返す\r\n */\r\nconst investTheElementIncluded = (selector) => {\r\n    const e = document.querySelector(selector);\r\n    return e ? true : false;\r\n};\r\n/**************************************************\r\n * Repeat checking if DOM has been acquired.\r\n * @param {string} selector : selector for dom about to acquire.\r\n * @param {boolean} timeoutAsResolve: If true, then timeout will not occure error.\r\n * @return {boolean} : Return boolean result. True as dom acquired. False as not.\r\n *\r\n * */\r\nconst repeatCheckQueryAcquired = (selector, timeoutAsResolve = false) => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        return yield repeatActionPromise(function () {\r\n            return investTheElementIncluded(selector);\r\n        }, timeoutAsResolve, 200, 10);\r\n    }\r\n    catch (e) {\r\n        throw e;\r\n    }\r\n});\r\n/*************************************************\r\n * Repeat to try query dom by given selector.\r\n * @param {string} selector: Selector for dom about to acquire.\r\n * @return {promise} represents HTMLElement as success.\r\n * @throws {DomManipulationError}\r\n *\r\n * repeatCheckQueryAcquired()でDOMが現れるまで待つ\r\n * 現れたらDOMを取得して返す\r\n *\r\n * 現れないでタイムアウトなら例外を投げる\r\n * */\r\nconst repeatQuerySelector = (selector) => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        yield repeatCheckQueryAcquired(selector);\r\n        return document.querySelector(selector);\r\n    }\r\n    catch (err) {\r\n        throw new DomManipulationError(`DomManipulationError: Could not get DOM by selector ${selector}`);\r\n    }\r\n});\r\n/*****************************************\r\n *  Initialize for detecting injected page status.\r\n *\r\n *  set up controlbar click event listener.\r\n *  set up MutationObserver of controlbar.\r\n * */\r\nconst initialize = () => __awaiter(void 0, void 0, void 0, function* () {\r\n    console.log('CONTENT SCRIPT INITIALIZING...');\r\n    try {\r\n        // いったんMutationObserverを停止してから...\r\n        if (moControlbar)\r\n            moControlbar.disconnect();\r\n        moControlbar = null;\r\n        moControlbar = new MutationObserver(moCallback);\r\n        // controlbarのDOMを再取得\r\n        if (controlbar)\r\n            controlbar.removeEventListener('click', handlerOfControlbar);\r\n        controlbar = null;\r\n        controlbar = yield repeatQuerySelector(selectors.transcript.controlbar);\r\n        controlbar.addEventListener('click', handlerOfControlbar);\r\n        // 再度、更新済のDOMに対してMutationObserverを設置する\r\n        moControlbar.observe(controlbar, config);\r\n        console.log('content script initialize has been done');\r\n    }\r\n    catch (err) {\r\n        if (err instanceof DomManipulationError)\r\n            console.error(`DomManipulationError: ${err.message}`);\r\n        throw err;\r\n    }\r\n});\r\n/**********************************************\r\n * Entry Point\r\n *\r\n * */\r\n(function () {\r\n    initialize()\r\n        .catch(e => {\r\n        chrome.runtime.sendMessage({\r\n            from: extensionNames.contentScript,\r\n            to: extensionNames.background,\r\n            success: false,\r\n            error: e\r\n        });\r\n    });\r\n})();\r\n//\r\n// --- LEGACY CODE ---------------------------------------------\r\n//\r\n// const initialize = async (): Promise<void> => {\r\n//   console.log(\"CONTENT SCRIPT INITIALIZING...\");\r\n//   try {\r\n//     // Set up listeners\r\n//     const w: number = document.documentElement.clientWidth;\r\n//     if (w > TOGGLE_VANISH_BOUNDARY) {\r\n//       const toggleButton: HTMLElement = document.querySelector<HTMLElement>(\r\n//         selectors.controlBar.transcript.toggleButton\r\n//       );\r\n//       toggleButton.addEventListener(\r\n//         \"click\",\r\n//         transcriptToggleButtonHandler,\r\n//         false\r\n//       );\r\n//       isWindowTooSmall = false;\r\n//     } else {\r\n//       isWindowTooSmall = true;\r\n//     }\r\n//     window.addEventListener(\"resize\", function () {\r\n//       clearTimeout(timerQueue);\r\n//       timerQueue = setTimeout(onWindowResizeHandler, RESIZE_TIMER);\r\n//     });\r\n//     const ccButton: HTMLElement = document.querySelector<HTMLElement>(\r\n//       selectors.controlBar.cc.popupButton\r\n//     );\r\n//     ccButton.addEventListener(\"click\", ccPopupButtonHandler, true);\r\n//     console.log(\"content script initialize has been done\");\r\n//   } catch (err) {\r\n//     console.error(err.message);\r\n//   }\r\n// };\r\n// -- LEGACY CODE -----------------------------------------------\r\n// THESE selectors MOVED TO './constansInContentScrip/ts'\r\n// 12/28\r\n//\r\n// const _selectors = {\r\n//     controlBar: {\r\n//         // \"closed captioning\"\r\n//         cc: {\r\n//             // 字幕メニューpopupボタン\r\n//             popupButton: \"button[data-purpose='captions-dropdown-button']\",\r\n//             // textContentで取得できる言語を取得可能\r\n//             //   languageList:\r\n//             //     \"button.udlite-btn.udlite-btn-large.udlite-btn-ghost.udlite-text-sm.udlite-block-list-item.udlite-block-list-item-small.udlite-block-list-item-neutral > div.udlite-block-list-item-content\",\r\n//             //\r\n//             // 言語リストを取得するには一旦languageButtonsを取得してからそれからquerySelectorする\r\n//             // いらないかも\r\n//             menuCheckButtons: 'button',\r\n//             menuList: '.udlite-block-list-item-content',\r\n//             menuListParent:\r\n//                 \"ul[role='menu'][data-purpose='captions-dropdown-menu']\",\r\n//             // 上記のセレクタのラッパーボタン。\r\n//             // 属性`aria-checked`で選択されているかどうかわかる\r\n//             checkButtons:\r\n//                 'button.udlite-btn.udlite-btn-large.udlite-btn-ghost.udlite-text-sm.udlite-block-list-item.udlite-block-list-item-small.udlite-block-list-item-neutral',\r\n//         },\r\n//         transcript: {\r\n//             toggleButton: \"button[data-purpose='transcript-toggle']\",\r\n//         },\r\n//     },\r\n//     sectionTitle: 'div.udlite-text-md.video-viewer--title-overlay--OoQ6e',\r\n// };\r\n// const initialize = (): void => {\r\n//     // Set up transcript check\r\n//     const isOpen: boolean = isTranscriptOpen();\r\n//     sendToBackground({ isOpened: isOpen });\r\n//     const e: HTMLElement = document.querySelector<HTMLElement>(\r\n//         SELECTORS.controlBar.transcript.toggleButton\r\n//     );\r\n//     e.addEventListener('click', transcriptToggleButtonHandler, false);\r\n//     // Set up language check\r\n//     const isEnglish: boolean = isSubtitleEnglish();\r\n//     sendToBackground({ isEnglish: isEnglish });\r\n//     const b: HTMLElement = document.querySelector<HTMLElement>(\r\n//         SELECTORS.controlBar.cc.popupButton\r\n//     );\r\n//     b.addEventListener('click', ccPopupButtonHandler, true);\r\n//     // Send section title to background\r\n//     sendTitle();\r\n// };\r\n/**\r\n * Callback of ClickEvent on CC Popup BUTTON\r\n *\r\n * Check if ClosedCaption Popup menu is opened.\r\n * If it's opened, then add onClick event listener to document\r\n * to detect subtitle change.\r\n *\r\n * NOTE: 変化タイミングの誤差のため\"aria-expanded\"がfalseの時にイベントリスナを取り付ける\r\n * */\r\n// const ccPopupButtonHandler = (ev: MouseEvent): void => {\r\n//     // popupメニューが開かれているかチェック\r\n//     // 開かれているならclickリスナをメニューラッパーとdocumentに着ける\r\n//     // とにかく\r\n//     // メニューの外側をクリックしたらすべてのリスナをremoveする\r\n//     console.log('CC popup button was clicked');\r\n//     // is it opening?\r\n//     const e: HTMLElement = document.querySelector<HTMLElement>(\r\n//         selectors.controlBar.cc.popupButton\r\n//     );\r\n//     // aria-expanded === trueのときになぜかfalseを返すので\r\n//     // 反対の結果を送信する\r\n//     if (e.getAttribute('aria-expanded') !== 'true') {\r\n//         // CC popupメニューが表示された\r\n//         document.removeEventListener('click', ccPopupMenuClickHandler, true);\r\n//         document.addEventListener('click', ccPopupMenuClickHandler, true);\r\n//     }\r\n// };\r\n/**\r\n * ブラウザウィンドウがX軸方向に境界線をまたいだときだけ機能する\r\n *\r\n * */\r\n// const onWindowResizeHandler = (ev): void => {\r\n//     const w: number = document.documentElement.clientWidth;\r\n//     console.log(w);\r\n//     // When window shrinks less than the boundary\r\n//     // Then send status.\r\n//     if (w < TOGGLE_VANISH_BOUNDARY && !isWindowTooSmall) {\r\n//         console.log('window is too small');\r\n//         isWindowTooSmall = true;\r\n//         // windowサイズが小さくなりすぎると、トグルボタンのDOMは消えるから\r\n//         // イベントリスナはremoveする必要がないけど、\r\n//         // 念のため\r\n//         const toggleButton: HTMLElement = document.querySelector<HTMLElement>(\r\n//             selectors.controlBar.transcript.toggleButton\r\n//         );\r\n//         if (!toggleButton) {\r\n//             sendToBackground({ isOpened: false });\r\n//         }\r\n//     }\r\n//     // When window bend over vanish boundary\r\n//     // Then reset toggle button to add listener.\r\n//     if (w >= TOGGLE_VANISH_BOUNDARY && isWindowTooSmall) {\r\n//         console.log('window is not small');\r\n//         isWindowTooSmall = false;\r\n//         const toggleButton: HTMLElement = document.querySelector<HTMLElement>(\r\n//             selectors.controlBar.transcript.toggleButton\r\n//         );\r\n//         toggleButton.addEventListener(\r\n//             'click',\r\n//             transcriptToggleButtonHandler,\r\n//             false\r\n//         );\r\n//     }\r\n// };\r\n/**\r\n * Callback of ClickEvent on toggle button of Transcript.\r\n *\r\n * NOTE: When click event fired, \"aria-expanded\" is not change its value yet.\r\n * So if this get true, then take that as \"aria-expanded\" about to be false.\r\n * */\r\n// const transcriptToggleButtonHandler = (ev?: MouseEvent): void => {\r\n//     const latest: HTMLElement = document.querySelector<HTMLElement>(\r\n//         selectors.controlBar.transcript.toggleButton\r\n//     );\r\n//     // \"aria-expanded\"変更直前の値なので反対を返す\r\n//     latest.getAttribute('aria-expanded') === 'true'\r\n//         ? sendToBackground({ isOpened: false })\r\n//         : sendToBackground({ isOpened: true });\r\n// Transcriptが消えるブラウザウィンドウX軸の境界値\r\n// const TOGGLE_VANISH_BOUNDARY: number = 584;\r\n// Transcriptがブラウザサイズによって消えているのかどうか\r\n// let isWindowTooSmall: boolean;\r\n// windowのonResizeイベント発火遅延用\r\n// let timerQueue: NodeJS.Timeout = null;\r\n// /**\r\n//  * Callback of ClickEvent on CC Popup MENU\r\n//  *\r\n//  * If user click outside of menu,\r\n//  * check subtitle has been changed.\r\n//  * If so, notify to background and remove listener from document.\r\n//  * Click inside do nothing.\r\n//  * */\r\n//  const ccPopupMenuClickHandler = (ev: PointerEvent): void => {\r\n//   console.log('[contentScript] ccPopupMenuClickHandler()...');\r\n//   const menu: HTMLElement = document.querySelector<HTMLElement>(\r\n//       selectors.controlBar.cc.menuListParent\r\n//   );\r\n//   const path: EventTarget[] = ev.composedPath();\r\n//   if (path.includes(menu)) {\r\n//       // menuの内側でclickが発生した\r\n//       // 何もしない\r\n//       console.log('[ccPopupMenuClickHandler()] clicked inside');\r\n//   } else {\r\n//       console.log('[ccPopupMenuClickHandler()] clicked outside');\r\n//       // menuの外側でclickが発生した\r\n//       // 字幕が変更されたかチェックして結果を送信する\r\n//       const r: boolean = isSubtitleEnglish();\r\n//       sendToBackground({ isEnglish: r });\r\n//       document.removeEventListener('click', ccPopupMenuClickHandler, true);\r\n//   }\r\n// };\r\n// /****\r\n//  * @param {selector} string : Selector for DOM about to capture.\r\n//  * @return {promise} HTMLElement : Resolved when matched, rejected when times out or not matched.\r\n//  *\r\n//  * 取得元のwebページがローディング中などでなかなかすぐにDOMがロードされないときとかに使う\r\n//  * 指定のDOMが取得できるまで、繰り返し取得を試みる\r\n//  * １０回取得を試みても取得できなかったらnullを返す\r\n//  * */\r\n//  const repeatQueryDom = async (selector: string): Promise<HTMLElement> => {\r\n//     return new Promise((resolve, reject): void => {\r\n//         let intervalId: NodeJS.Timer;\r\n//         let counter: number = 10;\r\n//         intervalId = setInterval(function () {\r\n//             if (counter <= 0) {\r\n//                 // Failed\r\n//                 console.log(\"[repeatQueryDom] Time out! It's over 10 times\");\r\n//                 clearInterval(intervalId);\r\n//                 reject(null);\r\n//             }\r\n//             console.log('[repeatQueryDom] query dom');\r\n//             const e: HTMLElement = document.querySelector(selector);\r\n//             if (e) {\r\n//                 // Succeed\r\n//                 console.log('[repeatQueryDom] Succeeed to query dom!');\r\n//                 clearInterval(intervalId);\r\n//                 resolve(e);\r\n//             } else counter--;\r\n//         }, INTERVAL_TIME);\r\n//     });\r\n// };\r\n"],"names":[],"sourceRoot":""}