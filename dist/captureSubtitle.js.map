{"version":3,"file":"captureSubtitle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://playground-chromeextension/./src/utils/constants.ts","webpack://playground-chromeextension/./src/utils/selectors.ts","webpack://playground-chromeextension/webpack/bootstrap","webpack://playground-chromeextension/webpack/runtime/define property getters","webpack://playground-chromeextension/webpack/runtime/hasOwnProperty shorthand","webpack://playground-chromeextension/webpack/runtime/make namespace object","webpack://playground-chromeextension/./src/contentScript/captureSubtitle.ts"],"sourcesContent":["/**************************************************\r\n * constants\r\n * ________________________________________________\r\n *\r\n * ************************************************/\r\nexport const _key_of_model_state__ = '_key_of_model_state__@&%8=8';\r\nexport const urlPattern = /https:\\/\\/www.udemy.com\\/course\\/*/gm;\r\nexport const extensionStatus = {\r\n    working: 'working',\r\n    notWorking: 'notWorking',\r\n    idle: 'idle',\r\n};\r\nexport const extensionNames = {\r\n    popup: 'popup',\r\n    contentScript: 'contentScript',\r\n    controller: 'controller',\r\n    captureSubtitle: 'captureSubtitle',\r\n    background: 'background',\r\n};\r\n//\r\n// Updated\r\n//\r\nexport const orderNames = {\r\n    // // Inject content script order\r\n    // injectCaptureSubtitleScript: 'injectCaptureSubtitleScript',\r\n    // injectExTranscriptScript: 'injectExTranscriptScript',\r\n    // From background to contentScript\r\n    sendStatus: 'sendStatus',\r\n    // from controller to background\r\n    sendSubtitles: 'sendSubtitles',\r\n    // order to disconnect port\r\n    disconnect: 'disconnect',\r\n    // from popup inquire the url is correct\r\n    inquireUrl: 'inquireUrl',\r\n    // from popup, run process\r\n    run: 'run',\r\n    // reset content script\r\n    reset: 'reset',\r\n    // Turn Off ExTranscript\r\n    turnOff: 'turnOff',\r\n    // something succeeded\r\n    success: 'success',\r\n};\r\n// --- constants for controller.js -------------------------------\r\n// // To pass to setTimeout\r\n// export const TEN_SEC: number = 10000;\r\n// transcript要素はwinodwサイズが975px以下の時にdashboardへ以上でsidebarへ移動する\r\nexport const RESIZE_BOUNDARY = 975;\r\n// sidebarのwidthは2通りあって、\r\n// 975px < w =< 1182pxだと300px, w > 1182pxで25%\r\nexport const SIDEBAR_WIDTH_BOUNDARY = 1182;\r\n// window onResize時の反応遅延速度\r\nexport const RESIZE_TIMER = 100;\r\nexport const SIGNAL = {\r\n    widthStatus: {\r\n        wideview: true,\r\n        middleview: false,\r\n    },\r\n};\r\nexport const positionStatus = {\r\n    sidebar: 'sidebar',\r\n    noSidebar: 'noSidebar',\r\n};\r\nexport const viewStatusNames = {\r\n    wideView: 'wideView',\r\n    middleView: 'middleView',\r\n};\r\n// ---- ABOUT PORT ----------------------------------\r\nexport const port_names = {\r\n    _requiring_subtitles: '_port_name_require_subtitles',\r\n    _injected_contentScript: '_port_name_injected_contentScript',\r\n};\r\n// // Usage\r\n// type _order = orderTypes[];\r\n// const oo: _order = [\r\n//   orderNames.sendStatus, orderNames.disconnect\r\n// ];\r\n// console.log(oo);\r\n// const messageHandler = (m: iMessage): void => {\r\n//   const { from, to, order } = m;\r\n//   // もしもorderプロパティが含まれていて、中身があれば\r\n//   if (order && order.length) {\r\n//     console.log(\"there is order\");\r\n//     //\r\n//     // この時点だとorderが何者かわからないみたいだからincludes()メソッドなんて使えないよ\r\n//     // というエラーが出る\r\n//     // でも使えた\r\n//     // codesandboxでは\r\n//     if (order.includes(orderNames.sendStatus)) {\r\n//       console.log(\"SEND STATUS\");\r\n//     }\r\n//     if (order.includes(orderNames.disconnect)) {\r\n//       console.log(\"DISCONNECT\");\r\n//     }\r\n//   }\r\n// };\r\n// messageHandler({\r\n//   from: \"background\",\r\n//   to: \"content script\",\r\n//   order: [\r\n//     orderNames.sendStatus, orderNames.disconnect\r\n//   ]\r\n// });\r\n// messageHandler({\r\n//   from: \"background\",\r\n//   to: \"content script\",\r\n//   order: []\r\n// });\r\n// messageHandler({\r\n//   from: \"background\",\r\n//   to: \"content script\"\r\n// });\r\n/*\r\n## 変数がいくつかの特定の値を持つように強制する方法\r\n\r\nhttps://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types\r\n\r\n```TypeScript\r\n\r\n// -- example 1 --\r\n\r\nlet x: \"hello\" = \"hello\";\r\n// OK\r\nx = \"hello\";\r\n// ...\r\nx = \"howdy\";\r\n// Type '\"howdy\"' is not assignable to type '\"hello\"'.\r\n\r\n// -- example 2 --\r\n\r\nfunction printText(s: string, alignment: \"left\" | \"right\" | \"center\") {\r\n  // ...\r\n}\r\nprintText(\"Hello, world\", \"left\");\r\nprintText(\"G'day, mate\", \"centre\");\r\nArgument of type '\"centre\"' is not assignable to parameter of type '\"left\" | \"right\" | \"center\"'.\r\n```\r\n\r\nhttps://typescript-jp.gitbook.io/deep-dive/type-system/literal-types\r\n\r\n\r\n\r\n*/\r\n","/***************************************************\r\n * SELECTORS\r\n * ________________________________________________\r\n *\r\n *\r\n *\r\n *\r\n * **************************************************/\r\n// --- Selectors related to Transcript ---------------------------\r\nexport const transcript = {\r\n    // HTMLSpanElement which is Highlight as current subtitle on movie.\r\n    highlight: 'span.transcript--highlight-cue--1bEgq',\r\n    // NodeListOf<HTMLSpanElement> which are list of subtitle element.\r\n    transcripts: 'div.transcript--cue-container--wu3UY p.transcript--underline-cue--3osdw span',\r\n    // top element of side bar\r\n    noSidebar: 'div.app--no-sidebar--1naXE',\r\n    sidebar: 'div.has-sidebar',\r\n    // High level element of Movie element\r\n    movieContainer: 'div.app--curriculum-item--2GBGE',\r\n    // Movie Replay button\r\n    replayButton: \"button[data-purpose='video-play-button-initial']\",\r\n};\r\n// --- Selectors related to control bar. -------------------------\r\nexport const controlBar = {\r\n    // \"closed captioning\"\r\n    cc: {\r\n        // 字幕メニューpopupボタン\r\n        popupButton: \"button[data-purpose='captions-dropdown-button']\",\r\n        // textContentで取得できる言語を取得可能\r\n        //   languageList:\r\n        //     \"button.udlite-btn.udlite-btn-large.udlite-btn-ghost.udlite-text-sm.udlite-block-list-item.udlite-block-list-item-small.udlite-block-list-item-neutral > div.udlite-block-list-item-content\",\r\n        //\r\n        // 言語リストを取得するには一旦languageButtonsを取得してからそれからquerySelectorする\r\n        // いらないかも\r\n        menuCheckButtons: 'button',\r\n        menuList: '.udlite-block-list-item-content',\r\n        menuListParent: \"ul[role='menu'][data-purpose='captions-dropdown-menu']\",\r\n        // 上記のセレクタのラッパーボタン。\r\n        // 属性`aria-checked`で選択されているかどうかわかる\r\n        checkButtons: 'button.udlite-btn.udlite-btn-large.udlite-btn-ghost.udlite-text-sm.udlite-block-list-item.udlite-block-list-item-small.udlite-block-list-item-neutral',\r\n    },\r\n    transcript: {\r\n        toggleButton: \"button[data-purpose='transcript-toggle']\",\r\n    },\r\n};\r\n// --- Selectors related ex-transcript -----------------------\r\nexport const EX = {\r\n    // Udemy page-specific selector\r\n    sidebarParent: '.app--content-column--HC_i1',\r\n    noSidebarParent: '.app--dashboard-content--r2Ce9',\r\n    movieContainer: '.app--body-container',\r\n    // 独自selector `ex--`を接頭辞とする\r\n    // sidebar ex-transcript selectors\r\n    sidebarWrapper: '.ex--sidebar-column',\r\n    sidebarSection: '.ex--sidebar--sidebar',\r\n    sidebarHeader: '.ex--sidebar--sidebar-header',\r\n    sidebarContent: '.ex--sidebar--content',\r\n    sidebarContentPanel: '.ex--sidebar-content-panel',\r\n    sidebarFooter: '.ex--sidebar-transcript--autoscroll-wrapper',\r\n    // sidebar width in case more than SIDEBAR_WIDTH_BOUNDARY\r\n    wideView: '.ex--sidebar--wideview',\r\n    // sidebar width in case less than SIDEBAR_WIDTH_BOUNDARY\r\n    middleView: '.ex--sidebar--middleview',\r\n    // bottom ex-transcript selectors\r\n    dashboardTranscriptWrapper: '.ex--dashboard-transcript-wrapper',\r\n    dashboardTranscriptHeader: '.ex--dashboard-transcript--header',\r\n    dashboardTranscriptPanel: '.ex--dashboard-transcript--transcript-panel',\r\n    dashboardTranscriptCueContainer: '.ex--dashboard-transcript--cue-container',\r\n    dashboardTranscriptCue: '.ex--dashboard-transcript--cue--underline',\r\n    dashboardTranscriptCueText: \"span[data-purpose='ex--dashboard-cue-text']\",\r\n    dashboardTranscriptBottom: '.ex--dashboard-transcript--autoscroll-wrapper',\r\n    // To Highlight Transcriot Cue Container\r\n    highlight: '.--highlight--',\r\n};\r\n// --- LEGACY -------------------------\r\n// sectionTitle: 'div.udlite-text-md.video-viewer--title-overlay--OoQ6e',\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/********************************************************\r\n * Capture Subtitles\r\n * __________________________________________________\r\n *\r\n * このcontent scriptは動的にwebページへinjectされる\r\n *\r\n * 機能：\r\n *  1. 要請が来るたび、字幕を取得し、整形しなおす\r\n *  2. 整形字幕データを送信する\r\n *\r\n * リセット処理は必要ない：\r\n *  order.resetに対応するときにおいて、\r\n *  DOM amnipulationは関数内部で実行時のみに行われるので\r\n *  イベントリスナなど付け替える必要がないため\r\n *\r\n *\r\n *********************************************************/\r\nimport * as selectors from '../utils/selectors';\r\nimport { orderNames, extensionNames, } from '../utils/constants';\r\n// --- chrome API Listener --------------------------------\r\n/**\r\n * chrome.runtime.onMessage.addListener()\r\n * _______________________________________\r\n *\r\n * 次のorderに応対する\r\n * - captureSubtitle: 字幕を取得して送信する\r\n *\r\n * */\r\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\r\n    const { from, to, order } = message;\r\n    if (to !== extensionNames.captureSubtitle)\r\n        return;\r\n    if (order && order.length) {\r\n        if (order.includes(orderNames.sendSubtitles)) {\r\n            const chunks = mainProcess();\r\n            if (sendResponse) {\r\n                sendResponse({\r\n                    subtitles: chunks,\r\n                    complete: true,\r\n                });\r\n            }\r\n            else {\r\n                throw new Error('[captureSubtitle] Cannot send response. sendResponse is nessesary but there is not the function');\r\n            }\r\n        }\r\n    }\r\n});\r\n// -- Capture Methods -----------------------------------\r\nconst capturingSubtitle = () => {\r\n    const spans = document.querySelectorAll(selectors.transcript.transcripts);\r\n    const subtitles = Array.from(spans).map((span, index) => {\r\n        return { index: index, subtitle: span.innerText.trim() };\r\n    });\r\n    return subtitles;\r\n};\r\n/*\r\n  subtitlePiecesToChunks\r\n  __________________________________________________\r\n    @param subtitles {subtitle_piece[]}\r\n    subtitle: Udemyの講義で流れてくる字幕一塊とその順番を表すindex\r\n\r\n    用語の意味：\r\n    piece: 破片  chunk: 塊\r\n    pieceはパンくずで、chunkは1斤パンである\r\n    chunksはスライスされた食パンのセットである\r\n\r\n    整形処理の流れ:\r\n    const chunks = subtitles.map( subtitle => {\r\n    })\r\n\r\n    subtitleの文末がピリオドまたはクエスチョンマークのsubtitleにであうまで、\r\n    buff[]へsubtitle.subtitleをpushし続ける\r\n\r\n    indexはbuff[]が空だった時だけ値を与える\r\n    そうすることでbuff[]へ一番初めにpushされたsubtitleのindexだけ記憶できる\r\n\r\n    このindex番号が後々字幕自動スクロールに必要になる\r\n\r\n    文末がピリオドまたはハテナのsubtitleにであったらbuff[]とindexがプロパティの\r\n    オブジェクトを生成して\r\n    chunksへ返す\r\n\r\n    以上が整形処理の流れ\r\n*/\r\nconst subtitlePiecesToChunks = function (subtitles) {\r\n    var buff = [];\r\n    var index = null;\r\n    const chunks = subtitles.map((subtitle) => {\r\n        // 塊を作り始める最初だけindexに値を与える\r\n        if (buff.length === 0) {\r\n            index = subtitle.index;\r\n        }\r\n        const s = subtitle.subtitle.trim().substr(-1, 1);\r\n        if (s === '.' || s === '?') {\r\n            const piece = {\r\n                index: index,\r\n                subtitle: [...buff, subtitle.subtitle].join(' '),\r\n            };\r\n            // 次のchunkのためにリセットする\r\n            buff = [];\r\n            index = null;\r\n            return piece;\r\n        }\r\n        else {\r\n            // 文末ピリオドまたはハテナのsubtitleにであうまで\r\n            // subtitleをpushし続ける\r\n            buff.push(subtitle.subtitle);\r\n        }\r\n    });\r\n    // undefinedを取り除いて返す\r\n    return chunks.filter((chunk) => chunk !== undefined);\r\n};\r\n/**\r\n *  Main Process Manager\r\n *\r\n *\r\n * */\r\nconst mainProcess = () => {\r\n    const subtitlePieces = capturingSubtitle();\r\n    const chunks = subtitlePiecesToChunks(subtitlePieces);\r\n    return chunks;\r\n};\r\n/*\r\n9/28:\r\n\r\n    setTimeout(() => {}, 10000)\r\n    chrome extensionのcontent scriptsはとっくに'load'イベントが過ぎたときにscriptをwebページに挿入するので\r\n    発火タイミングを設定するのが無理\r\n    なのでsetTimeout()を便宜上設定している\r\n\r\n\r\n9/29:\r\n\r\n    現時点でピリオド終了の文章の塊ができている\r\n    文章の塊にインデックスをつけた（index番号はpiecesの順番ではなくてwebページから取得したときの順番のうち、塊にしたときに）\r\n    文字列の連結を生成しているだけなので当然改行は含まれない\r\n    'undefined'が生成されている(何かの文章は失われていないと思われるけど不安)   : 未解決\r\n\r\n\r\n    `const piece = [...buff, string.text];`は\r\n    string.textが空の時にpieceが[undefined]になる\r\n\r\n    で、Array.prototype,join()は[undefined]がわたされても空の文字列を返す\r\n    なので\r\n    mapは空の文字列を返すはずで、undefinedにはならないはずなんだけどな～\r\n\r\n                // temporary for debuging.\r\n            if( piece.join(' ') === undefined) {\r\n                console.log(piece.join(' '))\r\n            }\r\n    というのを追加してみたけどundefinedは検出されず\r\n\r\n    ひとまず無視する\r\n\r\n\r\n10/6:\r\n    popup.jsと通信する\r\n    popup.jsでボタンが押されてから字幕取得できるようにする\r\n\r\n    popup.jsとcontentScript.jsとで通信する\r\n        popup.js request to capture subtitles\r\n        contentScript got request and begin to capture subtitles\r\n\r\n\r\n10/17: 自動スクロールの検知\r\n\r\n\r\n    detectScroll()\r\n    実現すること：\r\n            Udemyの講義ページで、\r\n            transcriptの字幕のうち現在表示されている字幕である「ハイライトされた字幕」要素と\r\n            そのハイライト字幕要素の含まれる要素群の中での順番を取得したい\r\n\r\n    内容:\r\n    - ハイライト字幕が変更になったことを示すイベントの取得\r\n            MutationObserverを使う\r\n            moを字幕要素すべてにつけて、classが変更になったら発火するしくみをつくった\r\n\r\n    - どの要素がハイライトされているのかの取得\r\n            MutationObserverが発火したら実行されるコールバック関数内部で\r\n            ハイライトされるcssセレクタ名を付けられている要素をquerySelectorで取得する\r\n\r\n            実はUdemyのtranscriptはなぜだか字幕要素が「ダブる」ことがあり\r\n            querySelectorAllとかするとまったく同じ字幕要素が複数取得する場合がある\r\n\r\n            なのでquerySelector()で取得すれば\r\n            たとえだぶっていても初めに一致した要素だけ返してくれる\r\n\r\n    - ハイライト要素とその番号の更新\r\n            ハイライト要素とその番号はcurrentHighlight()モジュールで管理している\r\n            このモジュールを先の処理で取得した要素とその番号に更新する\r\n\r\n10/21:\r\n自動スクロール検知の件：\r\n\r\n            detectScroll()で取得した字幕番号と、main()で取得している整形した字幕番号は一致している\r\n            （というのを雑に確認した。ちゃんとやりたいけどそれは後回しでいい）\r\n\r\n字幕整形の件：(全然今のところ優先度高くない)\r\n            1.\r\n            subtitlePiecesToChunks()の戻り値の配列にundefinedが入り込むのを何とかしたい\r\n            undefinedの代わりに空文字列にしたい\r\n            undefinedのままだと何かしらのエラーでundefinedなのかどうか判断できない\r\n\r\n            2.\r\n            ピリオド区切りだと一つの字幕の塊が長くなりすぎる\r\n            '?'も区切り文字の一つとして登録する\r\n\r\n整形字幕埋め込みの件:\r\n\r\n            CSSの出番ですね...\r\n            - とりあえず字幕をUdemyの講義ページに埋め込めることができるのか確認する\r\n            - 埋め込めるならばCSSで飾り付ける\r\n            - 埋め込めるならば任意の場所に字幕windowsを表示できるようにしたい\r\n\r\n整形字幕も自動スクロールさせる件：\r\n\r\n\r\n\r\n10/23:\r\n\r\n  整形字幕埋め込みの件\r\n\r\n\r\n11/12:\r\n\r\n    contentScript.tsでスクレイピングしたデータを保存する\r\n    \r\n\r\n\r\n1/11:\r\n\r\n  自動スクロール検知機能はたぶんcontroller.jsへ移したので\r\n  こちらでは凍結する\r\n  （未確認）\r\n*/\r\n// --- LEGCAY CODE ---------------------------------\r\n// // ---- Follow Auto-scroll Methods ------------------------------\r\n// const currentHighlight = (function () {\r\n//   var index: number = 0;\r\n//   var element: Element = null;\r\n//   return {\r\n//     getCurrentHighlight: function () {\r\n//       return Object.assign({}, { index, element });\r\n//     },\r\n//     setCurrentHighlight: function ({ i, e }: { i: number; e: Element }) {\r\n//       index = i;\r\n//       element = e;\r\n//     },\r\n//     resetCurrentHighlight: function () {\r\n//       index = 0;\r\n//       element = null;\r\n//     },\r\n//   };\r\n// })();\r\n/*\r\n    本家の自動スクロール機能を追跡する\r\n    自動スクロールで現在ハイライトされている字幕要素を追跡する\r\n\r\n    具体的には\r\n    トランスクリプト上の字幕要素には番号を順番に振り、\r\n    ハイライトされている字幕が映るたびに検知して次のハイライト要素とその番号を取得する\r\n*/\r\n// const detectScroll = (): void => {\r\n//   const _callback = (mr: MutationRecord[]): void => {\r\n//     const latestHighlight = document.querySelector(selectors.highlight);\r\n//     var latestIndex: number;\r\n//     // Update\r\n//     const list: NodeListOf<HTMLSpanElement> = document.querySelectorAll(\r\n//       selectors.transcripts\r\n//     );\r\n//     latestIndex = getElementIndexOfList(list, latestHighlight);\r\n//     if (latestIndex === -1) {\r\n//       console.error(\r\n//         \"Error: [detectScroll()] No elements is matched in transcript\"\r\n//       );\r\n//     } else {\r\n//       currentHighlight.setCurrentHighlight({\r\n//         i: latestIndex,\r\n//         e: latestHighlight,\r\n//       });\r\n//       console.log(\"OBSERVED\");\r\n//       console.log(latestHighlight);\r\n//       console.log(currentHighlight.getCurrentHighlight());\r\n//     }\r\n//   };\r\n//   const observer = new MutationObserver(_callback);\r\n//   // configuration of the observer:\r\n//   const config = { attributes: true, childList: false, subtree: false };\r\n//   //   target: span\r\n//   const transcripts: NodeListOf<Element> = document.querySelectorAll(\r\n//     selectors.transcripts\r\n//   );\r\n//   // set observer\r\n//   transcripts.forEach((ts, index) => {\r\n//     // pass in the target node, as well as the observer options\r\n//     observer.observe(ts, config);\r\n//   });\r\n// };\r\n// // いらないかも...\r\n// const setCurrentHighlight = (): void => {\r\n//   var count: number = 0;\r\n//   const list: NodeListOf<Element> = document.querySelectorAll(\r\n//     selectors.transcripts\r\n//   );\r\n//   const highlight: Element = document.querySelector(selectors.highlight);\r\n//   for (const el of Array.from(list)) {\r\n//     if (el === highlight) {\r\n//       currentHighlight.setCurrentHighlight({ i: count, e: el });\r\n//       break;\r\n//     }\r\n//     count++;\r\n//   }\r\n// };\r\n// const getElementIndexOfList = (\r\n//   from: NodeListOf<Element>,\r\n//   lookFor: Element\r\n// ): number => {\r\n//   var num: number = 0;\r\n//   for (const el of Array.from(from)) {\r\n//     if (el === lookFor) return num;\r\n//     num++;\r\n//   }\r\n//   // 一致するものがなかった場合\r\n//   return -1;\r\n// };\r\n// Duplicated 2/3\r\n//\r\n// const state = (function () {\r\n//   let _chunks: subtitle_piece[] = [];\r\n//   return {\r\n//       setChunks: (c: subtitle_piece[]): void => {\r\n//           // 常に上書き\r\n//           // 一旦全て配列を空にして\r\n//           // shallow copyを渡す\r\n//           _chunks.splice(0, _chunks.length);\r\n//           _chunks = c.map((subtitle) => {\r\n//               return { ...subtitle };\r\n//           });\r\n//       },\r\n//       getChunks: (): subtitle_piece[] => {\r\n//           // copyを渡すこと\r\n//           return _chunks.map((c) => {\r\n//               return { ...c };\r\n//           });\r\n//       },\r\n//       lengthOfChunks: (): number => {\r\n//           return _chunks.length;\r\n//       },\r\n//   };\r\n// })();\r\n"],"names":[],"sourceRoot":""}