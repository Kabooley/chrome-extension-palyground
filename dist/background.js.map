{"version":3,"file":"background.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://playground-chromeextension/./src/background/annotations.ts","webpack://playground-chromeextension/./src/utils/LocalStorage.ts","webpack://playground-chromeextension/./src/utils/background/State.ts","webpack://playground-chromeextension/./src/utils/constants.ts","webpack://playground-chromeextension/./src/utils/helpers.ts","webpack://playground-chromeextension/webpack/bootstrap","webpack://playground-chromeextension/webpack/runtime/define property getters","webpack://playground-chromeextension/webpack/runtime/hasOwnProperty shorthand","webpack://playground-chromeextension/webpack/runtime/make namespace object","webpack://playground-chromeextension/./src/background/background.ts"],"sourcesContent":["// base object for State<iProgress>\r\nexport const progressBase = {\r\n    isContentScriptInjected: false,\r\n    isCaptureSubtitleInjected: false,\r\n    isControllerInjected: false,\r\n    isSubtitleCapturing: false,\r\n    isSubtitleCaptured: false,\r\n    isExTranscriptStructured: false,\r\n};\r\n// modelBaseは新規プロパティの追加も削除もない\r\nexport const modelBase = {\r\n    isContentScriptInjected: false,\r\n    isCaptureSubtitleInjected: false,\r\n    isControllerInjected: false,\r\n    isSubtitleCapturing: false,\r\n    isSubtitleCaptured: false,\r\n    // NOTE: ExTranscriptがONかどうか\r\n    // RUNした後かどうか、でもある\r\n    // 表示、非表示は関係ない\r\n    isExTranscriptStructured: false,\r\n    // NOTE: 本家トランスクリプトが表示されているかどうか\r\n    // ONかどうかではなく、表示されているかどうか\r\n    // これが非表示なら、ExTranscriptも非表示にする\r\n    isTranscriptDisplaying: false,\r\n    isEnglish: false,\r\n    tabId: null,\r\n    url: null,\r\n    subtitles: null,\r\n};\r\n","/*\r\n    chrome.storage.localのclass化\r\n    ___________________________________________\r\n\r\n    NOTE:\r\n        1. インスタンスにつき一つだけlocalStorageへ保存するためのkeyを登録できる\r\n            なので一つのkeyに対するデータだけ保存できる\r\n\r\n        2. ~loadが返すのは{_key: 保存したデータ}であることに注意~\r\n            ~なので保存したデータだけに用がある場合がほ飛んだと思うので~\r\n            ~利用する側はそのまま使ってしまわないように注意~\r\n        load()のreturn する値を変更した\r\n\r\n    \r\n*/\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nexport class LocalStorage {\r\n    constructor(_key) {\r\n        this._key = _key;\r\n    }\r\n    _getLocalStorage(_key) {\r\n        return new Promise((resolve, reject) => {\r\n            // chrome.storage.local.get()はPromiseチェーンみたいなもの\r\n            chrome.storage.local.get(_key, (s) => {\r\n                if (chrome.runtime.lastError) {\r\n                    reject(chrome.runtime.lastError);\r\n                }\r\n                resolve(s);\r\n            });\r\n        });\r\n    }\r\n    save(data) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const obj = { [this._key]: data };\r\n                yield chrome.storage.local.set(obj);\r\n            }\r\n            catch (err) {\r\n                if (err === chrome.runtime.lastError) {\r\n                    console.error(err.message);\r\n                }\r\n                else {\r\n                    console.log(err);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    load() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const data = yield this._getLocalStorage(this._key);\r\n                // return data;\r\n                // 保存されたデータだけを返すようにした\r\n                return data[this._key];\r\n            }\r\n            catch (err) {\r\n                if (err === chrome.runtime.lastError) {\r\n                    console.error(err.message);\r\n                }\r\n                else {\r\n                    console.log(err);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    clearAll() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield chrome.storage.local.remove(this._key);\r\n        });\r\n    }\r\n}\r\n// -- USAGE --------------\r\n//\r\n// const ls_sectionTitle = new LocalStorage<string>(\"key_section_title\");\r\n// await ls_sectionTitle.save(someStringdata);\r\n// const data = await ls_sectionTitle.load();\r\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n/********************************************************\r\n * State class\r\n * ______________________________________________________\r\n *\r\n * NOTE:\r\n * 前提 : chrome.storage.localの使用\r\n * インスタンスには必ずオブジェクトを渡すこと\r\n * stringやnumberなどそのまま渡さないこと\r\n * 必ずkey-valueペアのオブジェクトを渡すこと\r\n *\r\n *\r\n * UPDATE:\r\n * - <TYPE extends object>でobjectだよってTypeScriptエンジンに伝えることができる\r\n *\r\n * ******************************************************/\r\nimport { LocalStorage } from \"../LocalStorage\";\r\nimport { deepCopier } from \"../helpers\";\r\n// @param key {string}: key for chrome.storage.local\r\nclass State {\r\n    constructor(key) {\r\n        this._key = key;\r\n        this._localStorage = new LocalStorage(this._key);\r\n    }\r\n    setState(prop) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._state = Object.assign(Object.assign({}, this._state), prop);\r\n            try {\r\n                yield this._localStorage.save(this._state);\r\n            }\r\n            catch (err) {\r\n                if (err === chrome.runtime.lastError) {\r\n                    console.error(err.message);\r\n                }\r\n                else {\r\n                    console.log(err);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    getState() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const s = yield this._localStorage.load();\r\n                this._state = Object.assign(Object.assign({}, this._state), s);\r\n                return deepCopier(this._state);\r\n            }\r\n            catch (err) {\r\n                if (err === chrome.runtime.lastError) {\r\n                    console.error(err.message);\r\n                }\r\n                else {\r\n                    console.log(err);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    clearStorage() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                yield this._localStorage.clearAll();\r\n            }\r\n            catch (err) {\r\n                if (err === chrome.runtime.lastError) {\r\n                    console.error(err.message);\r\n                }\r\n                else {\r\n                    console.log(err);\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\nexport default State;\r\n// --- USAGE -------------------------------------------------\r\n//\r\n// もしもbackground.tsへ組み込むことになっていたらとして...\r\n//\r\n// chrome.runtime.onInstalled.addListener(\r\n//   async (details: chrome.runtime.InstalledDetails) => {\r\n//       console.log('BACKGROUND RUNNING...');\r\n//       console.log(details.reason);\r\n//       stateList.clearStorage(\"stateExtension\");\r\n//       stateList.setState<iState>(\"stateExtension\", {\r\n//           scripts: {\r\n//               popup: 'notWorking',\r\n//               contentScript: 'notWorking',\r\n//               controller: 'notWorking',\r\n//               option: 'notWorking',\r\n//           },\r\n//           pageStatus: {\r\n//               isTranscriptOn: false,\r\n//               isEnglish: false,\r\n//               isWindowTooSmall: false,\r\n//           },\r\n//           progress: {\r\n//               capturing: false,\r\n//               captured: false,\r\n//               stored: false,\r\n//               restructured: false,\r\n//           },\r\n//       })\r\n//   }\r\n// );\r\n// // set up\r\n// const setupState = (): void => {\r\n//   // state of iState\r\n//   const key__extensionState: string = 'key__local_storage_state';\r\n//   const stateExtension = new State<iState>(key__extensionState);\r\n//   // state of subtitle_piece[]\r\n//   const key__subtitles: string = 'key__local_storage_subtitle';\r\n//   const stateSubtitles = new State<subtitle_piece[]>(key__subtitles);\r\n//   // state of tabId\r\n//   const key__tabId: string = 'key__tabId';\r\n//   const stateTabId = new State<number>(key__tabId);\r\n//   // state of sectionTitle\r\n//   const key__sectionTitle: string = 'key__sectionTitle';\r\n//   const stateSectionTitle = new State<string>(key__sectionTitle);\r\n//   // Register instances.\r\n//   stateList.register<iState>(\"stateExtension\", stateExtension);\r\n//   stateList.register<subtitle_piece[]>(\"stateSubtitles\", stateSubtitles);\r\n//   stateList.register<number>(\"stateTabId\", stateTabId);\r\n//   stateList.register<string>(\"stateSectionTitle\", stateSectionTitle);\r\n// };\r\n// // ---- MODULES --------------------------------------------------\r\n// interface iStateList {\r\n//   register: <TYPE>(name: string, instance: State<TYPE>) => void;\r\n//   unregister: (name: string) => void;\r\n//   setState: <TYPE>(name: string, data: TYPE) => Promise<void>;\r\n//   getState: <TYPE>(name: string)=> Promise<TYPE>;\r\n//   clearStorage:(name: string) => Promise<void>;\r\n// };\r\n// // Stateのインスタンスを保存しておく場所\r\n// // インスタンスをどこからでも呼出せるようにするためと、\r\n// // インスタンスをグローバル変数にしたくないからこんな面倒をしている\r\n// //\r\n// // background scriptがアンロードされる可能性を考えて\r\n// // 再ロードされても大丈夫にしておく\r\n// // ということで内部でインスタンスを呼び出し、登録する\r\n// const stateList: iStateList = (function () {\r\n//     console.log(\"stateList module invoked\");\r\n//   // _list will store these properties.\r\n//   // この場合の_listのAnnotationの仕方がわからない\r\n//   // _list = {\r\n//   //     stateSectionTitle: stateSectionTitle,\r\n//   //     stateExtension: stateExtension,\r\n//   //     stateSubtitles: stateSubtitles,\r\n//   //     stateTabId: stateTabId,\r\n//   // }\r\n//   var _list = {};\r\n//   setupState();\r\n//   return {\r\n//       register: <TYPE>(name: string, instance: State<TYPE>): void => {\r\n//           _list[name] = instance;\r\n//       },\r\n//       unregister: (name: string): void => {\r\n//           // これでinstanceもさくじょしていることになるかしら\r\n//           delete _list[name];\r\n//       },\r\n//       setState: async <TYPE>(name: string, data: TYPE): Promise<void> => {\r\n//           await _list[name].setState(data);\r\n//       },\r\n//       // Genericsは手続きが面倒かしら?\r\n//       getState: async <TYPE>(name: string): Promise<TYPE> => {\r\n//           return _list[name].getState();\r\n//       },\r\n//       clearStorage: async(name: string): Promise<void> => {\r\n//           await _list[name].clearStorage();\r\n//       },\r\n//       // 以下の呼出が問題を起こさなければこっちのほうがいいんだけどね\r\n//       // caller: <TYPE>(name: string): State<TYPE> => {\r\n//       //     return _list[name];\r\n//       // }\r\n//   };\r\n// })();\r\n// // USAGE stateList\r\n// const current = stateList.getState<iState>(\"stateExtension\");\r\n","/**************************************************\r\n * constants\r\n * ________________________________________________\r\n *\r\n * ************************************************/\r\nexport const _key_of_model_state__ = '_key_of_model_state__@&%8=8';\r\nexport const urlPattern = /https:\\/\\/www.udemy.com\\/course\\/*/gm;\r\nexport const extensionStatus = {\r\n    working: 'working',\r\n    notWorking: 'notWorking',\r\n    idle: 'idle',\r\n};\r\nexport const extensionNames = {\r\n    popup: 'popup',\r\n    contentScript: 'contentScript',\r\n    controller: 'controller',\r\n    captureSubtitle: 'captureSubtitle',\r\n    background: 'background',\r\n};\r\n//\r\n// Updated\r\n//\r\nexport const orderNames = {\r\n    // // Inject content script order\r\n    // injectCaptureSubtitleScript: 'injectCaptureSubtitleScript',\r\n    // injectExTranscriptScript: 'injectExTranscriptScript',\r\n    // From background to contentScript\r\n    sendStatus: 'sendStatus',\r\n    // from controller to background\r\n    sendSubtitles: 'sendSubtitles',\r\n    // order to disconnect port\r\n    disconnect: 'disconnect',\r\n    // from popup inquire the url is correct\r\n    inquireUrl: 'inquireUrl',\r\n    // from popup, run process\r\n    run: 'run',\r\n    // reset content script\r\n    reset: 'reset',\r\n    // Turn Off ExTranscript\r\n    turnOff: 'turnOff',\r\n    // something succeeded\r\n    success: 'success',\r\n};\r\n// --- constants for controller.js -------------------------------\r\n// // To pass to setTimeout\r\n// export const TEN_SEC: number = 10000;\r\n// transcript要素はwinodwサイズが975px以下の時にdashboardへ以上でsidebarへ移動する\r\nexport const RESIZE_BOUNDARY = 975;\r\n// sidebarのwidthは2通りあって、\r\n// 975px < w =< 1182pxだと300px, w > 1182pxで25%\r\nexport const SIDEBAR_WIDTH_BOUNDARY = 1182;\r\n// window onResize時の反応遅延速度\r\nexport const RESIZE_TIMER = 100;\r\nexport const SIGNAL = {\r\n    widthStatus: {\r\n        wideview: true,\r\n        middleview: false,\r\n    },\r\n};\r\nexport const positionStatus = {\r\n    sidebar: 'sidebar',\r\n    noSidebar: 'noSidebar',\r\n};\r\nexport const viewStatusNames = {\r\n    wideView: 'wideView',\r\n    middleView: 'middleView',\r\n};\r\n// ---- ABOUT PORT ----------------------------------\r\nexport const port_names = {\r\n    _requiring_subtitles: '_port_name_require_subtitles',\r\n    _injected_contentScript: '_port_name_injected_contentScript',\r\n};\r\n// // Usage\r\n// type _order = orderTypes[];\r\n// const oo: _order = [\r\n//   orderNames.sendStatus, orderNames.disconnect\r\n// ];\r\n// console.log(oo);\r\n// const messageHandler = (m: iMessage): void => {\r\n//   const { from, to, order } = m;\r\n//   // もしもorderプロパティが含まれていて、中身があれば\r\n//   if (order && order.length) {\r\n//     console.log(\"there is order\");\r\n//     //\r\n//     // この時点だとorderが何者かわからないみたいだからincludes()メソッドなんて使えないよ\r\n//     // というエラーが出る\r\n//     // でも使えた\r\n//     // codesandboxでは\r\n//     if (order.includes(orderNames.sendStatus)) {\r\n//       console.log(\"SEND STATUS\");\r\n//     }\r\n//     if (order.includes(orderNames.disconnect)) {\r\n//       console.log(\"DISCONNECT\");\r\n//     }\r\n//   }\r\n// };\r\n// messageHandler({\r\n//   from: \"background\",\r\n//   to: \"content script\",\r\n//   order: [\r\n//     orderNames.sendStatus, orderNames.disconnect\r\n//   ]\r\n// });\r\n// messageHandler({\r\n//   from: \"background\",\r\n//   to: \"content script\",\r\n//   order: []\r\n// });\r\n// messageHandler({\r\n//   from: \"background\",\r\n//   to: \"content script\"\r\n// });\r\n/*\r\n## 変数がいくつかの特定の値を持つように強制する方法\r\n\r\nhttps://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types\r\n\r\n```TypeScript\r\n\r\n// -- example 1 --\r\n\r\nlet x: \"hello\" = \"hello\";\r\n// OK\r\nx = \"hello\";\r\n// ...\r\nx = \"howdy\";\r\n// Type '\"howdy\"' is not assignable to type '\"hello\"'.\r\n\r\n// -- example 2 --\r\n\r\nfunction printText(s: string, alignment: \"left\" | \"right\" | \"center\") {\r\n  // ...\r\n}\r\nprintText(\"Hello, world\", \"left\");\r\nprintText(\"G'day, mate\", \"centre\");\r\nArgument of type '\"centre\"' is not assignable to parameter of type '\"left\" | \"right\" | \"center\"'.\r\n```\r\n\r\nhttps://typescript-jp.gitbook.io/deep-dive/type-system/literal-types\r\n\r\n\r\n\r\n*/\r\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __rest = (this && this.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n};\r\nexport const deepCopier = (data) => {\r\n    return JSON.parse(JSON.stringify(data));\r\n};\r\nexport const sendMessageToTabsPromise = (tabId, message) => __awaiter(void 0, void 0, void 0, function* () {\r\n    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {\r\n        chrome.tabs.sendMessage(tabId, message, (response) => __awaiter(void 0, void 0, void 0, function* () {\r\n            const { complete } = response, rest = __rest(response, [\"complete\"]);\r\n            complete\r\n                ? resolve(rest)\r\n                : reject('Send message to tabs went something wrong');\r\n        }));\r\n    }));\r\n});\r\nexport const sendMessagePromise = (message) => __awaiter(void 0, void 0, void 0, function* () {\r\n    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {\r\n        chrome.runtime.sendMessage(message, (response) => __awaiter(void 0, void 0, void 0, function* () {\r\n            const { complete } = response, rest = __rest(response, [\"complete\"]);\r\n            if (complete)\r\n                resolve(rest);\r\n            else\r\n                reject();\r\n        }));\r\n    }));\r\n});\r\nexport const tabsQuery = () => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        const w = yield chrome.windows.getCurrent();\r\n        const tabs = yield chrome.tabs.query({\r\n            active: true,\r\n            windowId: w.id,\r\n        });\r\n        return tabs[0];\r\n    }\r\n    catch (err) {\r\n        console.error(err.message);\r\n    }\r\n});\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/***************************************************************\r\n * background.ts\r\n * _____________________________________________________________\r\n *\r\n * As service worker and Application Layer.\r\n *\r\n *\r\n * chrome.runtime.onInstalled: Stateを初期化してstateへ保存する\r\n *  ***************************************************************/\r\n/**\r\n * 検証：\r\n * グローバルモジュールのmodelは、service workerがアンロードされたあとでも\r\n * 自身のinstanceを保持しているのか？\r\n *\r\n * 結果：\r\n * ぜんぜんアンロードされない\r\n * 10分くらい放っておいても問題ない...\r\n *\r\n * ということで雑だけれどservice workerでもわりとアンロードされないから\r\n * グローバル・モジュールに値を保持させるのはアリとする\r\n *\r\n *\r\n * TODO:\r\n *\r\n *\r\n * */\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __rest = (this && this.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n};\r\nimport { _key_of_model_state__, urlPattern, orderNames, extensionNames, } from '../utils/constants';\r\nimport { sendMessageToTabsPromise, tabsQuery } from '../utils/helpers';\r\nimport State from '../utils/background/State';\r\nimport { modelBase } from './annotations';\r\n//\r\n// --- Chrome API Listeners ---------------------------------\r\n//\r\n/***\r\n * chrome.runtime.onInstalled.addListener():\r\n *\r\n * Initialize State as iModel.\r\n * Always clear storage.\r\n * Set modelBase as initiali value.\r\n * */\r\nchrome.runtime.onInstalled.addListener((details) => __awaiter(void 0, void 0, void 0, function* () {\r\n    console.log(`[background] onInstalled: ${details.reason}`);\r\n    try {\r\n        state.unregister();\r\n        yield state.register(new State(_key_of_model_state__));\r\n        yield state.getInstance().clearStorage();\r\n        yield state.getInstance().setState(modelBase);\r\n    }\r\n    catch (err) {\r\n        console.error(err.message);\r\n    }\r\n}));\r\n/**\r\n * chrome.tabs.onUpdated.addListener()\r\n * ______________________________________________\r\n *\r\n * 機能：\r\n * URLが変更されたかどうかを検知する機能を実装する\r\n *\r\n * chrome.tabs.onUpdatedはすべてのタブにおけるイベントを検知する\r\n * なので関係ないタブに関することは無視する機能を実装する必要がある\r\n *\r\n * ブラウザの挙動に対してonUpdatedが反応したときの振舞に関して：\r\n *\r\n * - 拡張機能が未展開であるけど、Udemy 講義ページである\r\n * なにもしない\r\n *\r\n * - 拡張機能が展開されていて、同じタブで Udemy 講義ページだけど末尾の URL が変更されたとき\r\n * 拡張機能をリセットして引き続き展開する\r\n *\r\n * - 拡張機能が展開されていて、同じタブで Udemy 講義ページ以外の URL になった時\r\n * 拡張機能は OFF にする\r\n *\r\n * - タブが切り替わった\r\n *  何もしない\r\n *\r\n * - 拡張機能が展開されていたタブが閉じられた\r\n *  拡張機能を OFF にする\r\n *\r\n * */\r\nchrome.tabs.onUpdated.addListener((tabIdUpdatedOccured, changeInfo, Tab) => __awaiter(void 0, void 0, void 0, function* () {\r\n    console.log(changeInfo);\r\n    // \"https://www.udemy.com/course/*\"以外のURLなら無視する\r\n    const _state = state.getInstance();\r\n    const { url, tabId, isExTranscriptStructured } = yield _state.getState();\r\n    // 拡張機能が未展開、changeInfo.statusがloadingでないなら無視する\r\n    if (changeInfo.status !== 'loading' || !isExTranscriptStructured)\r\n        return;\r\n    // 拡張機能が展開済だとして、tabIdが展開済のtabId以外に切り替わったなら無視する\r\n    // return;\r\n    if (tabIdUpdatedOccured !== tabId)\r\n        return;\r\n    // 展開中のtabId && chnageInfo.urlがUdemy講義ページ以外のURLならば\r\n    // 拡張機能OFFの処理へ\r\n    if (isExTranscriptStructured && tabIdUpdatedOccured === tabId) {\r\n        // おなじURLでのリロードか？\r\n        if (changeInfo.url === undefined) {\r\n            // 拡張機能は何もしない\r\n            return;\r\n        }\r\n        else if (!changeInfo.url.match(urlPattern)) {\r\n            // Udemy講義ページ以外に移動した\r\n            // 拡張機能OFF処理へ\r\n            // TODO: 拡張機能OFF処理の実装\r\n            console.log('[background] OFF this extension');\r\n        }\r\n        // 展開中のtabIdである && changeInfo.urlが講義ページだけど末尾が変化した(#以下は無視)\r\n        // 動画が切り替わった判定\r\n        else if (changeInfo.url.match(urlPattern) &&\r\n            changeInfo.url !== url) {\r\n            // 動画が切り替わった\r\n            // TODO: リセット処理へ\r\n            console.log('[background] RESET this extension');\r\n            yield handlerOfReset(tabIdUpdatedOccured, changeInfo.url);\r\n        }\r\n    }\r\n}));\r\n/**\r\n *\r\n *\r\n * */\r\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\r\n    if (message.to !== extensionNames.background)\r\n        return;\r\n    sortMessage(message, sender, sendResponse);\r\n    // NOTE: MUST RETURN TRUE\r\n    // If you wanna use asynchronous function.\r\n    return true;\r\n});\r\nconst sortMessage = (message, sender, sendResponse) => {\r\n    switch (message.from) {\r\n        case extensionNames.popup:\r\n            handlerOfPopupMessage(message, sender, sendResponse);\r\n            break;\r\n        case extensionNames.contentScript:\r\n            handlerOfContentScriptMessage(message, sender, sendResponse);\r\n            break;\r\n        case extensionNames.captureSubtitle:\r\n            handlerOfCaptureSubtitleMessage(message, sender, sendResponse);\r\n            break;\r\n        case extensionNames.controller:\r\n            handlerOfControllerMessage(message, sender, sendResponse);\r\n            break;\r\n    }\r\n};\r\n//\r\n// --- Message Handlers ----------------------------------------\r\n//\r\n/**\r\n *\r\n *\r\n * */\r\nconst handlerOfPopupMessage = (message, sender, sendResponse) => __awaiter(void 0, void 0, void 0, function* () {\r\n    console.log('[background] Message from Popup');\r\n    try {\r\n        const { order } = message, rest = __rest(message, [\"order\"]);\r\n        if (order && order.length) {\r\n            // DEBUG: make sure what message got\r\n            console.log('[background] Validate URL');\r\n            //\r\n            // popupが開かれるたびに呼び出される処理\r\n            //\r\n            // なのでurlが正しいかだけを返信する\r\n            // Stateを変更しない\r\n            if (order.includes(orderNames.inquireUrl)) {\r\n                const isValidPage = yield handlerOfVerifyValidPage();\r\n                sendResponse({ correctUrl: isValidPage, complete: true });\r\n            }\r\n            // 拡張機能の実行命令\r\n            if (order.includes(orderNames.run)) {\r\n                // DEBUG: make sure what message got\r\n                console.log('[background] RUN');\r\n                //\r\n                const isSuccess = yield handlerOfRun();\r\n                // sendResponse({ successDeployment: isSuccess, complete: true });\r\n                if (!isSuccess) {\r\n                    // ここでエラーを出すのか\r\n                    // handlerOfRunでエラーを出すのか\r\n                    // 未定\r\n                    sendResponse({ complete: true, success: false });\r\n                }\r\n                else {\r\n                    sendResponse({ complete: true, success: true });\r\n                }\r\n            }\r\n        }\r\n    }\r\n    catch (err) {\r\n        console.error(err.message);\r\n    }\r\n});\r\n/**\r\n *\r\n *\r\n * */\r\nconst handlerOfContentScriptMessage = (message, sender, sendResponse) => __awaiter(void 0, void 0, void 0, function* () {\r\n    console.log('[background] Message from contentScript.js');\r\n    try {\r\n        const { order } = message, rest = __rest(message, [\"order\"]);\r\n        const _state = state.getInstance();\r\n        const { isExTranscriptStructured, isTranscriptDisplaying, isEnglish, tabId, } = yield _state.getState();\r\n        if (order && order.length) {\r\n        }\r\n        // ExTRanscriptを表示する条件が揃わなくなったとき...\r\n        if (!rest.isTranscriptDisplaying || !rest.language) {\r\n            // ExTranscriptを非表示にするかする\r\n            // もしもトランスクリプトが表示中であったならば\r\n            if (isExTranscriptStructured && isTranscriptDisplaying) {\r\n                console.log('[background] Hide ExTranscript...');\r\n                yield handlerOfHide(tabId);\r\n            }\r\n            // Stateを更新する\r\n            let s = {};\r\n            if (rest.isTranscriptDisplaying !== undefined) {\r\n                s['isTranscriptDisplaying'] = rest.isTranscriptDisplaying;\r\n            }\r\n            if (rest.language !== undefined) {\r\n                s['isEnglish'] = rest.language;\r\n            }\r\n            yield _state.setState(s);\r\n            sendResponse({ complete: true });\r\n        }\r\n        // トランスクリプトが再表示されたとき...\r\n        if (rest.isTranscriptDisplaying) {\r\n            // ExTranscriptが非表示だったならば再表示させる\r\n            if (isExTranscriptStructured && !isTranscriptDisplaying) {\r\n                // 非表示だった状態から\r\n                // 表示させる処理\r\n                yield handlerOfReset(tabId);\r\n                yield _state.setState({ isTranscriptDisplaying: true });\r\n                sendResponse({ complete: true });\r\n            }\r\n        }\r\n        // 字幕が英語を選択されたとき...\r\n        if (rest.language) {\r\n            // ExTranscriptが非表示だったならば再表示させる\r\n            if (isExTranscriptStructured && !isEnglish) {\r\n                // 非表示だった状態から\r\n                // 表示させる処理\r\n                yield handlerOfReset(tabId);\r\n                yield _state.setState({\r\n                    isTranscriptDisplaying: true,\r\n                    isEnglish: true,\r\n                });\r\n                sendResponse({ complete: true });\r\n            }\r\n        }\r\n    }\r\n    catch (err) {\r\n        console.error(err.message);\r\n    }\r\n});\r\n/**\r\n *\r\n *\r\n * */\r\nconst handlerOfCaptureSubtitleMessage = (message, sender, sendResponse) => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n    }\r\n    catch (err) {\r\n        console.error(err.message);\r\n    }\r\n});\r\n/**\r\n *\r\n *\r\n * */\r\nconst handlerOfControllerMessage = (message, sender, sendResponse) => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n    }\r\n    catch (err) {\r\n        console.error(err.message);\r\n    }\r\n});\r\n//\r\n// --- Order Handlers -------------------------------------------\r\n//\r\n/**\r\n *\r\n *\r\n * */\r\nconst handlerOfVerifyValidPage = (_url) => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        let url = '';\r\n        if (_url === undefined) {\r\n            const tab = yield tabsQuery();\r\n            url = tab.url;\r\n        }\r\n        else\r\n            url = _url;\r\n        const result = url.match(urlPattern);\r\n        return result && result.length ? true : false;\r\n    }\r\n    catch (err) {\r\n        console.error(err.message);\r\n    }\r\n});\r\n/**\r\n * handler of RUN order.\r\n * _______________________________________________\r\n *\r\n * TODO:\r\n * - 処理中の失敗を段階ごとに理由と一緒に返せるようにしたい\r\n *  失敗理由によってはエラーじゃない場合もある\r\n *  あと各段階でおこるエラースローは各段階のcatchへキャッチさせたほうがいいのかな？\r\n *\r\n *\r\n * - injectしたコンテントスクリプトからのinject成功信号を受信したら、こっちに処理が戻ってくるようにしたい\r\n *  いまのワイの腕では無理\r\n *\r\n * - controller.jsへの字幕データの渡し方を変更したい\r\n *\r\n *\r\n * 例：\r\n * contentScriptのステータスを確認してみたら、字幕が英語じゃなかった\r\n * ならば「英語字幕じゃなかったからキャンセルしたよ」をpopupへ送信できる\r\n * */\r\nconst handlerOfRun = () => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        const _state = state.getInstance();\r\n        const tabs = yield tabsQuery();\r\n        const { url, id } = tabs;\r\n        // <phase 1> is URL correct?\r\n        // 拡張機能を展開するurlとtabIdを保存するため\r\n        if (!handlerOfVerifyValidPage(url)) {\r\n            // TODO: 失敗またはキャンセルの方法未定義...\r\n            // ひとまずfalseを返している\r\n            return false;\r\n        }\r\n        // Save valid url and current tab that extension popup opened.\r\n        yield _state.setState({ url: url, tabId: id });\r\n        //<phase 2> inject contentScript.js\r\n        const { tabId } = yield _state.getState();\r\n        yield chrome.scripting.executeScript({\r\n            target: { tabId: tabId },\r\n            files: ['contentScript.js'],\r\n        });\r\n        yield _state.setState({ isContentScriptInjected: true });\r\n        // TODO: ここでcontentScript.jsが展開完了したのを確認したうえで次に行きたいのだが...実装する技術がない...\r\n        const { language, isTranscriptDisplaying } = yield sendMessageToTabsPromise(tabId, {\r\n            from: extensionNames.background,\r\n            to: extensionNames.contentScript,\r\n            order: [orderNames.sendStatus],\r\n        });\r\n        // 結果がどうあれ現状の状態を保存する\r\n        yield _state.setState({\r\n            isEnglish: language,\r\n            isTranscriptDisplaying: isTranscriptDisplaying,\r\n        });\r\n        // 字幕が英語じゃない、またはトランスクリプトがONでないならば\r\n        // キャンセル\r\n        if (!language || !isTranscriptDisplaying) {\r\n            // TODO: 失敗またはキャンセルの方法未定義...\r\n            // ひとまずfalseを返している\r\n            return false;\r\n        }\r\n        // <phase 3> inject captureSubtitle.js\r\n        // 字幕データを取得する\r\n        yield chrome.scripting.executeScript({\r\n            target: { tabId: tabId },\r\n            files: ['captureSubtitle.js'],\r\n        });\r\n        yield _state.setState({ isCaptureSubtitleInjected: true });\r\n        // TODO: ここでcontent scriptが展開完了したのを確認したうえで次に行きたいのだが...\r\n        const { subtitles } = yield sendMessageToTabsPromise(tabId, {\r\n            from: extensionNames.background,\r\n            to: extensionNames.captureSubtitle,\r\n            order: [orderNames.sendSubtitles],\r\n        });\r\n        // TODO: subtitlesのデータがおかしくないか検査したい\r\n        // 条件分岐で検査に合格したら字幕データを保存\r\n        // 不合格でエラー\r\n        yield _state.setState({ subtitles: subtitles });\r\n        // <phase 4> inject controller.js\r\n        yield chrome.scripting.executeScript({\r\n            target: { tabId: tabId },\r\n            files: ['controller.js'],\r\n        });\r\n        yield _state.setState({ isControllerInjected: true });\r\n        // const { success } = await sendMessageToTabsPromise(tabId, {\r\n        //     from: extensionNames.background,\r\n        //     to: extensionNames.controller,\r\n        //     order: [orderNames.sendStatus],\r\n        // });\r\n        // // TODO: 字幕データの渡し方が未定義\r\n        // // 今のところ、controller側から要求して渡している\r\n        // // これをこちらから渡すようにしたい...\r\n        // if (!success) {\r\n        //     // TODO: 失敗またはキャンセルの方法未定義...\r\n        //     // ひとまずfalseを返している\r\n        //     return false;\r\n        // }\r\n        const s = yield _state.getState();\r\n        yield sendMessageToTabsPromise(tabId, {\r\n            from: extensionNames.background,\r\n            to: extensionNames.controller,\r\n            subtitles: s.subtitles,\r\n        });\r\n        yield _state.setState({ isExTranscriptStructured: true });\r\n        // ...ここまででエラーがなければ成功\r\n        return true;\r\n    }\r\n    catch (err) {\r\n        console.error(err.message);\r\n    }\r\n});\r\n/**\r\n * handler of RESET\r\n * ________________________________________________\r\n *\r\n * ExTranscriptを再生成する\r\n * 本家トランスくリプトが表示されているかどうか、\r\n * 字幕が英語かどうかはこの関数内でチェックしない\r\n *\r\n * 処理内容：\r\n *\r\n * - 各 content scriptのリセット：\r\n * content scriptはinjectされたまま（というか除去する手段はない）\r\n * なのでcontent scriptの状態を変化させないといかん\r\n * contentScript.js リセット不要\r\n * captureSubtitle.js 要リセット\r\n * controller.js 要リセット\r\n *\r\n * - captureSubtitle.jsから字幕データを取得する\r\n *\r\n * - controller.jsへ字幕データを渡す\r\n *\r\n * */\r\nconst handlerOfReset = (tabId, newUrl) => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        console.log('[background] RESET Begin...');\r\n        const _state = state.getInstance();\r\n        const { url } = yield _state.getState();\r\n        // stateの更新：\r\n        // urlをtabs.onUpdatedが起こったときのURLにする\r\n        yield _state.setState({\r\n            url: newUrl === undefined ? url : newUrl,\r\n            isTranscriptDisplaying: false,\r\n            isSubtitleCaptured: false,\r\n            isSubtitleCapturing: true,\r\n            // TODO: 既存配列変数を再度空にするのはこの方法で大丈夫なのか?\r\n            //\r\n            subtitles: [],\r\n        });\r\n        // reset 処理: 各content scritpのリセットを実施する\r\n        yield resetEachContentScript(tabId);\r\n        // 成功したとして、\r\n        // データ再取得処理\r\n        // \r\n        // TODO: 字幕データがUdemyのページでロード完了されるまで時間を置く\r\n        // \r\n        // ロード完了を検知する仕組みはないので\r\n        // 無辺ループで長さが1以上の配列を取得できるまで取得を繰り返すか\r\n        // 予め決めた時間で取得させるか...\r\n        const resFromCaptureSubtitle = yield sendMessageToTabsPromise(tabId, {\r\n            from: extensionNames.background,\r\n            to: extensionNames.captureSubtitle,\r\n            order: [orderNames.sendSubtitles],\r\n        });\r\n        console.log(resFromCaptureSubtitle.subtitles);\r\n        // TODO: Validate subtitles data.\r\n        if (resFromCaptureSubtitle.subtitles.length) {\r\n            console.error('Error: subtitle data is empty');\r\n        }\r\n        //\r\n        // If okay, then save subtitles data.\r\n        yield _state.setState({\r\n            isSubtitleCaptured: true,\r\n            isSubtitleCapturing: false,\r\n            subtitles: resFromCaptureSubtitle.subtitles,\r\n        });\r\n        // NOTE: 一旦resetオーダーを出してから字幕を送ること\r\n        const resetOrder = yield sendMessageToTabsPromise(tabId, {\r\n            from: extensionNames.background,\r\n            to: extensionNames.controller,\r\n            order: [orderNames.reset],\r\n        });\r\n        const resetSubtitle = yield sendMessageToTabsPromise(tabId, {\r\n            from: extensionNames.background,\r\n            to: extensionNames.controller,\r\n            subtitles: resFromCaptureSubtitle.subtitles,\r\n        });\r\n        if (!resetOrder.success || !resetSubtitle) {\r\n            throw new Error(`Error: Failed to reset controller. ${resetOrder.success\r\n                ? ''\r\n                : resetOrder.failureReason + resetSubtitle.success\r\n                    ? ''\r\n                    : resetSubtitle.failureReason} `);\r\n        }\r\n        yield _state.setState({\r\n            isTranscriptDisplaying: true,\r\n        });\r\n        // ここまで何も問題なければRESET成功\r\n        console.log('[background] RESET Complete!');\r\n    }\r\n    catch (err) {\r\n        console.error(err.message);\r\n    }\r\n});\r\n/**\r\n * handler of hide ExTranscript\r\n * ________________________________________\r\n *\r\n * 実際には隠すのではなくて、ExTranscriptを消す\r\n *\r\n * 発動条件：\r\n *\r\n * - 本家トランスクリプトが非表示になった\r\n * - 英語字幕以外の字幕を選択されてしまった\r\n *\r\n *\r\n * */\r\nconst handlerOfHide = (tabId) => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        console.log('[background] handlerOfHide hides ExTranscript...');\r\n        const _state = state.getInstance();\r\n        // stateの更新：\r\n        yield _state.setState({\r\n            isTranscriptDisplaying: false,\r\n            isSubtitleCaptured: false,\r\n            // TODO: <確認>既存配列変数を再度空にするのはこの方法で大丈夫なのか?\r\n            subtitles: [],\r\n        });\r\n        // reset 処理: 各content scritpのリセットを実施する\r\n        const r = yield sendMessageToTabsPromise(tabId, {\r\n            from: extensionNames.background,\r\n            to: extensionNames.controller,\r\n            order: [orderNames.turnOff],\r\n        });\r\n        if (!r.success) {\r\n            throw new Error('Failed to hide ExTranscript');\r\n        }\r\n    }\r\n    catch (err) {\r\n        console.error(err.message);\r\n    }\r\n});\r\n/**\r\n *\r\n *\r\n * TODO:\r\n * - 処理中の失敗を段階ごとに理由と一緒に返せるようにしたい\r\n * */\r\nconst resetEachContentScript = (tabId) => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        const r = yield sendMessageToTabsPromise(tabId, {\r\n            from: extensionNames.background,\r\n            to: extensionNames.controller,\r\n            order: [orderNames.reset],\r\n        });\r\n        if (!r.success)\r\n            throw new Error(`Error: Failed to reset controller.js. ${r.failureReason}`);\r\n    }\r\n    catch (err) {\r\n        console.error(err.message);\r\n    }\r\n});\r\n//\r\n// --- Other Methods ----------------------------------------\r\n//\r\n/*\r\n    state module\r\n    ______________________________________________\r\n    service workerなので、Stateを常に参照できるようにしておくため\r\n    モジュール化したState\r\n\r\n    Stateのインスタンスはここへカプセル化され、\r\n    getInstance()を通して参照が渡される\r\n\r\n    検証してみた結果、アンロード、ロードに耐えうる模様\r\n*/\r\nexport const state = (function () {\r\n    let _instance = null;\r\n    return {\r\n        register: (m) => {\r\n            _instance = m;\r\n        },\r\n        // unregisterする場面では、もはやStateは要らないから\r\n        // Stateを削除しちゃってもいいと思う\r\n        unregister: () => {\r\n            _instance = null;\r\n        },\r\n        getInstance: () => {\r\n            return _instance;\r\n        },\r\n    };\r\n})();\r\n//\r\n// --- LEGACY ----------------------------\r\n//\r\n"],"names":[],"sourceRoot":""}